<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head next-head"/><meta name="description" content="Gyumin Dev Blog" class="next-head"/><meta property="og:type" content="website" class="next-head"/><meta property="og:description" content="Gyumin Dev Blog" class="next-head"/><meta property="og:image" content="https://gyumindev.github.io/static/image_jacket.jpg" class="next-head"/><meta property="og:image:alt" content="Jacket Image" class="next-head"/><meta property="og:image:width" content="800" class="next-head"/><meta property="og:image:height" content="600" class="next-head"/><meta property="og:locale" content="ko_KR" class="next-head"/><meta property="og:site_name" content="GM Ground" class="next-head"/><title class="next-head">GM Ground - clean-code-javascript-ko</title><meta name="robots" content="index,follow" class="next-head"/><meta name="googlebot" content="index,follow" class="next-head"/><meta property="og:url" content="https://gyumindev.github.io/clean-code-javascript-ko" class="next-head"/><meta property="og:title" content="GM Ground - clean-code-javascript-ko" class="next-head"/><link rel="preload" href="/_next/7cf28e76-71b0-4e5a-892a-1c761e451d8a/page/post.js" as="script"/><link rel="preload" href="/_next/7cf28e76-71b0-4e5a-892a-1c761e451d8a/page/_app.js" as="script"/><link rel="preload" href="/_next/7cf28e76-71b0-4e5a-892a-1c761e451d8a/page/_error.js" as="script"/><link rel="preload" href="/_next/static/commons/main-b281c6af7916d7257e47.js" as="script"/><meta charSet="utf-8"/><meta name="google-site-verification" content="10J968HKOHy9lsJe8mHJ2FcxSCrCE83rgtoR10aO1c4"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><link href="https://fonts.googleapis.com/css?family=Noto+Sans+KR" rel="stylesheet"/><link rel="stylesheet" href="/static/font.css"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossOrigin="anonymous"/><style data-styled-components="eAjofs bItfsH dIxdIy hpQBbR BWBQG kFFUPk dstscJ cFWucn fWgWJp dSPDsA jThIxF ilNniD kRNjcA">
/* sc-component-id: HeaderTitle__Title-yyayft-0 */
.kFFUPk{padding:10px 30px 10px 30px;background-color:#2c3e50;min-width:120px;color:white;font-weight:300;-webkit-appearance:none;cursor:pointer;}
/* sc-component-id: HeaderNavigation__Navigation-e03zhr-0 */
.dstscJ{margin-right:10px;font-weight:600;cursor:pointer;}
/* sc-component-id: SideBar__Container-dkscfx-0 */
.eAjofs{position:fixed;top:0;right:-375px;height:100%;width:375px;margin:auto;background-color:black;-moz-transition:all 200ms ease-in;-webkit-transition:all 200ms ease-in;-o-transition:all 200ms ease-in;-webkit-transition:all 200ms ease-in;transition:all 200ms ease-in;box-shadow:0;} @media screen and (min-width:320px) and (max-width:667px){.eAjofs{width:100%;right:-100%;}} @media screen and (min-width:320px) and (max-width:667px) and (orientation:portrait){.eAjofs{width:100%;right:-100%;}}
/* sc-component-id: Header__Container-sc-12ks5ow-0 */
.hpQBbR{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-transition:all 0.3s;transition:all 0.3s;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}
/* sc-component-id: Header__BarIcon-sc-12ks5ow-1 */
.BWBQG{position:absolute;top:35px;right:25px;cursor:pointer;color:black;}
/* sc-component-id: Header__SideBarImage-sc-12ks5ow-2 */
.bItfsH{position:absolute;top:0;width:100%;height:400px;opacity:1;}
/* sc-component-id: Header__SideBarHeader-sc-12ks5ow-3 */
.dIxdIy{position:absolute;width:100%;top:150px;left:25%;color:white;}
/* sc-component-id: Footer__Container-sc-121sa8t-0 */
.jThIxF{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:50px;padding:0 20px 0 20px;}
/* sc-component-id: Footer__Icon-sc-121sa8t-1 */
.kRNjcA{cursor:pointer;color:black;}
/* sc-component-id: Footer__PrevIcon-sc-121sa8t-2 */
.ilNniD{cursor:pointer;color:black;opacity:1;}
/* sc-component-id: main__Wrapper-sc-9wosp5-0 */
.cFWucn{padding:40px 20px 20px 20px;height:auto;min-height:500px;-webkit-box-pack:start;-webkit-justify-content:start;-ms-flex-pack:start;justify-content:start;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;opacity:1;}
/* sc-component-id: post__Container-sc-18d9za3-0 */
.fWgWJp{padding:10px 10px 10px 10px;display:inline-block;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;max-width:800px;} @media screen and (min-width:320px) and (max-width:667px){.fWgWJp{width:100px;}} @media screen and (min-width:320px) and (max-width:667px) and (orientation:portrait){.fWgWJp{width:90%;}}
/* sc-component-id: post__DisqusContainer-sc-18d9za3-1 */
.dSPDsA{margin-top:30px;}</style></head><body><div id="__next"><div><div><div class="SideBar__Container-dkscfx-0 eAjofs"><img class="Header__SideBarImage-sc-12ks5ow-2 bItfsH" src="/static/image_jacket.jpg"/><h1 class="Header__SideBarHeader-sc-12ks5ow-3 dIxdIy">GM Ground</h1></div><div class="Header__Container-sc-12ks5ow-0 hpQBbR"><i class="fas fa-bars fa-2x Header__BarIcon-sc-12ks5ow-1 BWBQG"></i><h2 class="HeaderTitle__Title-yyayft-0 kFFUPk">GM Ground</h2></div><div class="Header__Container-sc-12ks5ow-0 hpQBbR"><div><a class="HeaderNavigation__Navigation-e03zhr-0 dstscJ">홈</a><a class="HeaderNavigation__Navigation-e03zhr-0 dstscJ">About</a></div></div></div><div class="main__Wrapper-sc-9wosp5-0 cFWucn"><div class="post__Container-sc-18d9za3-0 fWgWJp"><div><h1>clean-code-javascript</h1><ul><li>Updated date 2017.1.31</li><li>현재 원문의 <a href="https://github.com/ryanmcdermott/clean-code-javascript/commit/ac6a51d640064ec4ac6cada7af477df8967dd193">ac6a51d</a>
까지 반영되어 있습니다.</li></ul><h2>목차</h2><ol><li><a href="#소개introduction">소개(Introduction)</a></li><li><a href="#변수variables">변수(Variables)</a></li><li><a href="#함수functions">함수(Functions)</a></li><li><a href="#객체와-자료구조objects-and-data-structures">객체와 자료구조(Objects and Data Structures)</a></li><li><a href="#클래스classes">클래스(Classes)</a></li><li><a href="#테스트testing">테스트(Testing)</a></li><li><a href="#동시성concurrency">동시성(Concurrency)</a></li><li><a href="#에러-처리error-handling">에러 처리(Error Handling)</a></li><li><a href="#포맷팅formatting">포맷팅(Formatting)</a></li><li><a href="#주석comments">주석(Comments)</a></li><li><p><a href="#번역translation">번역(Translation)</a></p></li></ol><h2>소개(Introduction)</h2><p><img alt="코드를 읽을 때 소리 지르는 숫자로 소프트웨어 품질을 추정하는 유머 사진" src="http://www.osnews.com/images/comics/wtfm.jpg"/></p><p>이 글은 소프트웨어 방법론에 관한 책들 중 Robert C. Martin&#x27;s의 책인 <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882"><em>Clean Code</em></a>에 있는 내용을 JavaScript 언어에 적용시켜 적은 글 입니다.
이 글은 단순히 Style Guide가 아니라 JavaScript로 코드를 작성할때 읽기 쉽고, 재사용 가능하며 리팩토링 가능하게끔 작성하도록 도와줍니다.</p><p>여기 있는 모든 원칙이 엄격히 지켜져야하는 것은 아니며, 보편적으로 통용되는 원칙은 아닙니다. 이것들은 지침일 뿐이며 <code>Clean Code</code>의 저자가 수년간 경험한 내용을 바탕으로 정리한 것입니다.</p><p>소프트웨어 엔지니어링 역사는 50년을 조금 넘겼지만 우리는 아직도 많은 것들을 배우고 있습니다.
그리고 소프트웨어 아키텍쳐가 건축설계 만큼이나 오래되었을때 우리는 아래 규칙들보다 더 엄격한 규칙들을 따라야 할지도 모릅니다.
하지만 지금 당장은 이 가이드 라인을 당신과 당신 팀이 작성하는 JavaScript 코드의 품질을 평가하는 기준으로 삼으세요.</p><p>한가지 더 덧붙이자면, 이 원칙들을 알게된다해서 당장 더 나은 개발자가 되는 것은 아니며 코드를 작성할 때 
실수를 하지 않게 해주는 것은 아닙니다. 훌륭한 도자기들이 처음엔 말랑한 점토부터 시작하듯이 모든 코드들은 처음부터 완벽할 수 없습니다.
하지만 당신은 팀원들과 같이 코드를 리뷰하며 점점 완벽하게 만들어가야 합니다. 당신이 처음 작성한 코드를 고칠 때 절대로 자신을 질타하지 마세요.
대신 코드를 부수고 더 나은 코드를 만드세요!</p><h2><strong>변수(Variables)</strong></h2><h3>의미있고 발음하기 쉬운 변수 이름을 사용하세요</h3><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">const yyyymmdstr = moment().format(&#x27;YYYY/MM/DD&#x27;);</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">const currentDate = moment().format(&#x27;YYYY/MM/DD&#x27;);</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>동일한 유형의 변수에 동일한 어휘를 사용하세요</h3><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">getUserInfo();
getClientData();
getCustomerRecord();</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">getUser();</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>검색가능한 이름을 사용하세요</h3><p>우리는 작성할 코드보다 읽을 코드가 더 많습니다. 그렇기 때문에 코드를 읽기 쉽고 검색 가능하게 작성해야 합니다.
그렇지 않으면 여러분의 코드를 이해하려고 하는 사람들에게 큰 어려움을 줍니다.
검색가능한 이름으로 만드세요.
<a href="https://github.com/danielstjules/buddy.js">buddy.js</a> 그리고
<a href="https://github.com/eslint/eslint/blob/660e0918933e6e7fede26bc675a0763a6b357c94/docs/rules/no-magic-numbers.md">ESLint</a>
와 같은 도구들이 이름이 정해져있지 않은 상수들을 발견하고 고칠 수 있게 도와줍니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">// 대체 86400000 무엇을 의미하는 걸까요?
setTimeout(blastOff, 86400000);</code></pre><p><strong>좋은 예</strong></p><pre><code class="language-javascript">// 대문자로 `const` 전역 변수를 선언하세요
const MILLISECONDS_IN_A_DAY = 86400000;
setTimeout(blastOff, MILLISECONDS_IN_A_DAY);</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>의도를 나타내는 변수들을 사용하세요</h3><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">const address = &#x27;One Infinite Loop, Cupertino 95014&#x27;;
const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
saveCityZipCode(address.match(cityZipCodeRegex)[1], address.match(cityZipCodeRegex)[2]);</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">const address = &#x27;One Infinite Loop, Cupertino 95014&#x27;;
const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
const [, city, zipCode] = address.match(cityZipCodeRegex) || [];
saveCityZipCode(city, zipCode);</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>자신만 알아볼 수 있는 작명을 피하세요</h3><p>명시적인 것이 암시적인 것보다 좋습니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">const locations = [&#x27;서울&#x27;, &#x27;인천&#x27;, &#x27;수원&#x27;];
locations.forEach(l =&gt; {
  doStuff();
  doSomeOtherStuff();
  // ...
  // ...
  // ...
  // 잠깐, `l`은 또 뭘까요?
  dispatch(l);
});</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">const locations = [&#x27;서울&#x27;, &#x27;인천&#x27;, &#x27;수원&#x27;];
locations.forEach(location =&gt; {
  doStuff();
  doSomeOtherStuff();
  // ...
  // ...
  // ...
  dispatch(location);
});</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>문맥상 필요없는 것들을 쓰지 마세요</h3><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">const Car = {
  carMake: &#x27;BMW&#x27;,
  carModel: &#x27;M3&#x27;,
  carColor: &#x27;파란색&#x27;
};

function paintCar(car) {
  car.carColor = &#x27;빨간색&#x27;;
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">const Car = {
  make: &#x27;BMW&#x27;,
  model: &#x27;M3&#x27;,
  color: &#x27;파란색&#x27;
};

function paintCar(car) {
  car.color = &#x27;빨간색&#x27;;
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>기본 매개변수가 short circuiting 트릭이나 조건문 보다 깔끔합니다</h3><p>기본 매개변수는 종종 short circuiting 트릭보다 깔끔합니다. 기본 매개변수는 매개변수가 <code>undefined</code>일때만 
적용됩니다. <code>&#x27;&#x27;</code>, <code>&quot;&quot;</code>, <code>false</code>, <code>null</code>, <code>0</code>, <code>NaN</code> 같은 <code>falsy</code>한 값들은 기본 매개변수가 적용되지 않습니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function createMicrobrewery(name) {
  const breweryName = name || &#x27;Hipster Brew Co.&#x27;;
  // ...
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function createMicrobrewery(name = &#x27;Hipster Brew Co.&#x27;) {
  // ...
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h2><strong>함수(Functions)</strong></h2><h3>함수 인자는 2개 이하가 이상적입니다</h3><p>매개변수의 개수를 제한 하는 것은 함수 테스팅을 쉽게 만들어 주기 때문에 중요합니다. 만약 매개변수가 3개 이상일 경우엔
테스트 해야하는 경우의 수가 많아지고 각기 다른 인수들로 여러 사례들을 테스트 해야합니다.</p><p>1개나 2개의 인자를 가지고 있는 것이 가장 이상적인 케이스입니다.
그리고 3개의 인자는 가능한 피해야합니다. 그것보다 더 많다면 통합되어야합니다.
만약 당신이 2개 이상의 인자를 가진 함수를 사용한다면 그 함수에게 너무 많은 역할을 하게 만든 것입니다.
그렇지 않은 경우라면 대부분의 경우 상위 객체는 1개의 인자만으로 충분합니다.</p><p>JavaScript를 사용할 때 많은 보일러플레이트 없이 바로 객체를 만들 수 있습니다.
그러므로 당신이 만약 많은 인자들을 사용해야 한다면 객체를 이용할 수 있습니다.</p><p>함수가 기대하는 속성을 좀더 명확히 하기 위해서 es6의 비구조화(destructuring) 구문을 사용할 수 있고
이 구문에는 몇가지 장점이 있습니다.</p><ol><li>어떤 사람이 그 함수의 시그니쳐(인자의 타입, 반환되는 값의 타입 등)를 볼 때 어떤 속성이 사용되는지
즉시 알 수 있습니다.</li><li>또한 비구조화는 함수에 전달된 인수 객체의 지정된 기본타입 값을 복제하며 이는 사이드이펙트가
일어나는 것을 방지합니다. 참고로 인수 객체로부터 비구조화된 객체와 배열은 복제되지 않습니다.</li><li>Linter를 사용하면 사용하지않는 인자에 대해 경고해주거나 비구조화 없이 코드를 짤 수 없게 할 수 있습니다.</li></ol><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function createMenu(title, body, buttonText, cancellable) {
  // ...
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function createMenu({ title, body, buttonText, cancellable }) {
  // ...
}

createMenu({
  title: &#x27;Foo&#x27;,
  body: &#x27;Bar&#x27;,
  buttonText: &#x27;Baz&#x27;,
  cancellable: true
});</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>함수는 하나의 행동만 해야합니다</h3><p>이것은 소프트웨어 엔지니어링에서 가장 중요한 규칙입니다. 함수가 1개 이상의 행동을 한다면 작성하는 것도, 테스트하는 것도, 이해하는 것도 어려워집니다.
당신이 하나의 함수에 하나의 행동을 정의하는 것이 가능해진다면 함수는 좀 더 고치기 쉬워지고 코드들은 읽기 쉬워질 것입니다.
많은 원칙들 중 이것만 알아간다 하더라도 당신은 많은 개발자들을 앞설 수 있습니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function emailClients(clients) {
  clients.forEach(client =&gt; {
    const clientRecord = database.lookup(client);
    if (clientRecord.isActive()) {
      email(client);
    }
  });
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function emailClients(clients) {
  clients
    .filter(isClientActive)
    .forEach(email);
}

function isClientActive(client) {
  const clientRecord = database.lookup(client);
  return clientRecord.isActive();
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>함수명은 함수가 무엇을 하는지 알 수 있어야 합니다</h3><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function AddToDate(date, month) {
  // ...
}

const date = new Date();

// 뭘 추가하는 건지 이름만 보고 알아내기 힘듭니다.
AddToDate(date, 1);</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function AddMonthToDate(date, month) {
  // ...
}

const date = new Date();
AddMonthToDate(date, 1);</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>함수는 단일 행동을 추상화 해야합니다</h3><p>추상화된 이름이 여러 의미를 내포하고 있다면 그 함수는 너무 많은 일을 하게끔 설계된 것입니다.
함수들을 나누어서 재사용가능하고 테스트하기 쉽게 만드세요.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function parseBetterJSAlternative(code) {
  const REGEXES = [
    // ...
  ];

  const statements = code.split(&#x27; &#x27;);
  const tokens = [];
  REGEXES.forEach(REGEX =&gt; {
    statements.forEach(statement =&gt; {
      // ...
    });
  });

  const ast = [];
  tokens.forEach(token =&gt; {
    // lex...
  });

  ast.forEach(node =&gt; {
    // parse...
  });
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function tokenize(code) {
  const REGEXES = [
    // ...
  ];

  const statements = code.split(&#x27; &#x27;);
  const tokens = [];
  REGEXES.forEach(REGEX =&gt; {
    statements.forEach(statement =&gt; {
      tokens.push( /* ... */ );
    });
  });

  return tokens;
}

function lexer(tokens) {
  const ast = [];
  tokens.forEach(token =&gt; {
    ast.push( /* ... */ );
  });

  return ast;
}

function parseBetterJSAlternative(code) {
  const tokens = tokenize(code);
  const ast = lexer(tokens);
  ast.forEach(node =&gt; {
    // parse...
  });
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>중복된 코드를 작성하지 마세요</h3><p>중복된 코드를 작성하지 않기위해 최선을 다하세요.
중복된 코드가 있다는 것은 어떤 로직을 수정해야 할 일이 생겼을 때 수정 해야할 코드가 한 곳 이상이라는 것을 뜻합니다.</p><p>만약 당신이 레스토랑을 운영하면서 토마토나 양파, 마늘, 고추같은 것들의 재고관리를 해야한다고 생각해보세요.
재고가 적혀있는 종이가 여러장 있다면 토마토나 양파의 재고가 변동되었을 때 재고가 적혀있는 모든 종이를 수정해야 합니다.
만약 재고를 관리하는 종이가 한 장이었다면 한 장의 재고 목록만 수정하면 됐겠죠!</p><p>종종 코드를 살펴보면 사소한 몇몇의 차이점 때문에 중복된 코드를 작성한 경우가 있고
이런 차이점들은 대부분 똑같은 일을 하는 분리된 함수들을 갖도록 강요합니다.
즉 중복 코드를 제거한다는 것은 하나의 함수 / 모듈 / 클래스를 사용하여 이 여러 가지 사소한 차이점을 처리 할 수 있는
추상화를 만드는 것을 의미합니다.</p><p>그리고 추상화 할 부분이 남아있는 것은 위험하기때문에 <em>클래스</em> 섹션에 제시된 여러 원칙들을 따라야 합니다.
잘 추상화 하지 못한 코드는 중복된 코드보다 나쁠 수 있으므로 조심하세요. 즉 추상화를 잘 할 수 있다면
그렇게 하라는 말입니다. 코드의 중복을 피한다면 여러분이 원할 때 언제든 한 곳만 수정해도 다른 모든 코드에
반영되게 할 수 있습니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function showDeveloperList(developers) {
  developers.forEach(developers =&gt; {
    const expectedSalary = developer.calculateExpectedSalary();
    const experience = developer.getExperience();
    const githubLink = developer.getGithubLink();
    const data = {
      expectedSalary,
      experience,
      githubLink
    };

    render(data);
  });
}

function showManagerList(managers) {
  managers.forEach(manager =&gt; {
    const expectedSalary = manager.calculateExpectedSalary();
    const experience = manager.getExperience();
    const portfolio = manager.getMBAProjects();
    const data = {
      expectedSalary,
      experience,
      portfolio
    };

    render(data);
  });
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function showEmployeeList(employees) {
  employees.forEach((employee) =&gt; {
    const expectedSalary = employee.calculateExpectedSalary();
    const experience = employee.getExperience();

    let portfolio = employee.getGithubLink();

    if (employee.type === &#x27;manager&#x27;) {
      portfolio = employee.getMBAProjects();
    }

    const data = {
      expectedSalary,
      experience,
      portfolio
    };

    render(data);
  });
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>Object.assign을 사용해 기본 객체를 만드세요</h3><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">const menuConfig = {
  title: null,
  body: &#x27;Bar&#x27;,
  buttonText: null,
  cancellable: true
};

function createMenu(config) {
  config.title = config.title || &#x27;Foo&#x27;;
  config.body = config.body || &#x27;Bar&#x27;;
  config.buttonText = config.buttonText || &#x27;Baz&#x27;;
  config.cancellable = config.cancellable === undefined ? config.cancellable : true;

}

createMenu(menuConfig);</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">const menuConfig = {
  title: &#x27;Order&#x27;,
  // 유저가 &#x27;body&#x27; key의 value를 정하지 않았다.
  buttonText: &#x27;Send&#x27;,
  cancellable: true
};

function createMenu(config) {
  config = Object.assign({
    title: &#x27;Foo&#x27;,
    body: &#x27;Bar&#x27;,
    buttonText: &#x27;Baz&#x27;,
    cancellable: true
  }, config);

  // config는 이제 다음과 동일합니다: {title: &quot;Order&quot;, body: &quot;Bar&quot;, buttonText: &quot;Send&quot;, cancellable: true}
  // ...
}

createMenu(menuConfig);</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>매개변수로 플래그를 사용하지 마세요</h3><p>플래그를 사용하는 것 자체가 그 함수가 한가지 이상의 역할을 하고 있다는 것을 뜻합니다.
boolean 기반으로 함수가 실행되는 코드가 나뉜다면 함수를 분리하세요.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function createFile(name, temp) {
  if (temp) {
    fs.create(`./temp/${name}`);
  } else {
    fs.create(name);
  }
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function createFile(name) {
  fs.create(name);
}

function createTempFile(name) {
  createFile(`./temp/${name}`);
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>사이드 이펙트를 피하세요 (part 1)</h3><p>함수는 값을 받아서 어떤 일을 하거나 값을 리턴할때 사이드 이팩트를 만들어냅니다.
사이드 이팩트는 파일에 쓰여질 수도 있고, 전역 변수를 수정할 수 있으며, 실수로 모든 돈을 다른 사람에게 보낼 수도 있습니다.</p><p>당신은 때때로 프로그램에서 사이드 이팩트를 만들어야 할 때가 있습니다. 아까 들었던 예들 중 하나인 파일작성을 할 때와 같이 말이죠.
이 때 여러분이 해야할 일은 파일 작성을 하는 한 개의 함수를 만드는 일 입니다. 파일을 작성하는 함수나 클래스가
여러개 존재하면 안됩니다. 반드시 하나만 있어야 합니다.</p><p>즉, 어떠한 구조체도 없이 객체 사이의 상태를 공유하거나, 무엇이든 쓸 수 있는 변경 가능한 데이터 유형을 사용하거나,
같은 사이드 이펙트를 만들어내는 것을 여러개 만들거나하면 안됩니다. 여러분들이 이러한 것들을 지키며 코드를 작성한다면
대부분의 다른 개발자들보다 행복할 수 있습니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">// 아래 함수에 의해 참조되는 전역 변수입니다.
// 이 전역 변수를 사용하는 또 하나의 함수가 있다고 생각해보세요. 이제 이 변수는 배열이 될 것이고, 프로그램을 망가뜨리겠죠.
let name = &#x27;Ryan McDermott&#x27;;

function splitIntoFirstAndLastName() {
  name = name.split(&#x27; &#x27;);
}

splitIntoFirstAndLastName();

console.log(name); // [&#x27;Ryan&#x27;, &#x27;McDermott&#x27;];</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function splitIntoFirstAndLastName(name) {
  return name.split(&#x27; &#x27;);
}

const name = &#x27;Ryan McDermott&#x27;;
const newName = splitIntoFirstAndLastName(name);

console.log(name); // &#x27;Ryan McDermott&#x27;;
console.log(newName); // [&#x27;Ryan&#x27;, &#x27;McDermott&#x27;];</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>사이드 이펙트를 피하세요 (part 2)</h3><p>자바스크립트에서는 기본타입 자료형은 값을 전달하고 객체와 배열은 참조를 전달합니다.
객체와 배열인 경우를 한번 살펴봅시다. 우리가 만든 함수는 장바구니 배열에 변화를 주며
이 변화는 구매목록에 어떤 상품을 추가하는 기능 같은 것을 말합니다.
만약 <code>장바구니</code> 배열을 사용하는 어느 다른 함수가 있다면 이러한 추가에 영향을 받습니다.
이것은 좋을 수도 있지만, 안좋을 수도 있습니다. 안좋은 예를 한번 상상해봅시다.</p><p>유저가 구매하기 버튼을 눌러 <code>구매</code> 함수를 호출합니다. 이는 네트워크 요청을 생성하고 서버에 <code>장바구니</code> 배열을 보냅니다.
하지만 네트워크 연결이 좋지않아서 <code>구매</code> 함수는 다시한번 네트워크 요청을 보내야 하는 상황이 생겼습니다.
이때, 사용자가 네트워크 요청이 시작되기 전에 실수로 원하지 않는 상품의 &quot;장바구니에 추가&quot; 버튼을 실수로 클릭하면 어떻게될까요?
실수가 있고난 뒤, 네트워크 요청이 시작되면 <code>장바구니에 추가</code> 함수 때문에 실수로 변경된 <code>장바구니</code> 배열을 서버에 보내게 됩니다.</p><p>가장 좋은 방법은 <code>장바구니에 추가</code>는 항상 <code>장바구니</code> 배열을 복제하여 수정하고 복제본을 반환하는 것입니다.
이렇게하면 장바구니 참조를 보유하고있는 다른 함수가 다른 변경 사항의 영향을 받지 않게됩니다.</p><p>이 접근법에대해 말하고 싶은 것이 두가지 있습니다.</p><ol><li>실제로 입력된 객체를 수정하고 싶은 경우가 있을 수 있지만 이러한 예제를 생각해보고 적용해보면 그런 경우는
거의 없다는 것을 깨달을 수 있습니다. 그리고 대부분의 것들이 사이드 이펙트 없이 리팩토링 될 수 있습니다.</li><li>큰 객체를 복제하는 것은 성능 측면에서 값이 매우 비쌉니다. 운좋게도 이런게 큰 문제가 되지는 않습니다.
왜냐하면 이러한 프로그래밍 접근법을 가능하게해줄 <a href="https://facebook.github.io/immutable-js/">좋은 라이브러리</a>가 있기 때문입니다.
이는 객체와 배열을 수동으로 복제하는 것처럼 메모리 집약적이지 않게 해주고 빠르게 복제해줍니다.</li></ol><p><strong>Bad:</strong></p><pre><code class="language-javascript">const addItemToCart = (cart, item) =&gt; {
  cart.push({ item, date: Date.now() });
};</code></pre><p><strong>Good:</strong></p><pre><code class="language-javascript">const addItemToCart = (cart, item) =&gt; {
  return [...cart, { item, date : Date.now() }];
};</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>전역 함수를 사용하지 마세요</h3><p>전역 환경을 사용하는 것은 JavaScript에서 나쁜 관행입니다. 왜냐하면 다른 라이브러리들과의 충돌이 일어날 수 있고,
당신의 API를 쓰는 유저들은 운영환경에서 예외가 발생하기 전까지는 문제를 인지하지 못할 것이기 때문입니다. 예제를 하나 생각해봅시다.
JavaScript의 네이티브 Array 메소드를 확장하여 두 배열 간의 차이를 보여줄 수있는 <code>diff</code> 메소드를 사용하려면 어떻게 해야할까요? 
새로운 함수를 <code>Array.prototype</code>에 쓸 수도 있지만, 똑같은 일을 시도한 다른 라이브러리와 충돌 할 수 있습니다.
다른 라이브러리가 <code>diff</code> 메소드를 사용하여 첫번째 요소와 마지막 요소의 차이점을 찾으면 어떻게 될까요?
이것이 그냥 ES2015/ES6의 classes를 사용해서 전역 <code>Array</code>를 상속해버리는 것이 훨씬 더 나은 이유입니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">Array.prototype.diff = function diff(comparisonArray) {
  const hash = new Set(comparisonArray);
  return this.filter(elem =&gt; !hash.has(elem));
};</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class SuperArray extends Array {
  diff(comparisonArray) {
    const hash = new Set(comparisonArray);
    return this.filter(elem =&gt; !hash.has(elem));
  }
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>명령형 프로그래밍보다 함수형 프로그래밍을 지향하세요</h3><p>JavaScript는 Haskell처럼 함수형 프로그래밍 언어는 아니지만 함수형 프로그래밍처럼 작성할 수 있습니다.
함수형 언어는 더 깔끔하고 테스트하기 쉽습니다. 가능하면 이 방식을 사용하도록 해보세요.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">const programmerOutput = [
  {
    name: &#x27;Uncle Bobby&#x27;,
    linesOfCode: 500
  }, {
    name: &#x27;Suzie Q&#x27;,
    linesOfCode: 1500
  }, {
    name: &#x27;Jimmy Gosling&#x27;,
    linesOfCode: 150
  }, {
    name: &#x27;Gracie Hopper&#x27;,
    linesOfCode: 1000
  }
];

let totalOutput = 0;

for (let i = 0; i &lt; programmerOutput.length; i++) {
  totalOutput += programmerOutput[i].linesOfCode;
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">const programmerOutput = [
  {
    name: &#x27;Uncle Bobby&#x27;,
    linesOfCode: 500
  }, {
    name: &#x27;Suzie Q&#x27;,
    linesOfCode: 1500
  }, {
    name: &#x27;Jimmy Gosling&#x27;,
    linesOfCode: 150
  }, {
    name: &#x27;Gracie Hopper&#x27;,
    linesOfCode: 1000
  }
];

const totalOutput = programmerOutput
  .map(programmer =&gt; programmer.linesOfCode)
  .reduce((acc, linesOfCode) =&gt; acc + linesOfCode, INITIAL_VALUE);</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>조건문을 캡슐화 하세요</h3><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">if (fsm.state === &#x27;fetching&#x27; &amp;&amp; isEmpty(listNode)) {
  // ...
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function shouldShowSpinner(fsm, listNode) {
  return fsm.state === &#x27;fetching&#x27; &amp;&amp; isEmpty(listNode);
}

if (shouldShowSpinner(fsmInstance, listNodeInstance)) {
  // ...
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>부정조건문을 사용하지 마세요</h3><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function isDOMNodeNotPresent(node) {
  // ...
}

if (!isDOMNodeNotPresent(node)) {
  // ...
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function isDOMNodePresent(node) {
  // ...
}

if (isDOMNodePresent(node)) {
  // ...
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>조건문 작성을 피하세요</h3><p>조건문 작성을 피하라는 것은 매우 불가능한 일로 보입니다. 이 얘기를 처음 듣는 사람들은 대부분 &quot;<code>If</code>문 없이 어떻게 코드를 짜나요?&quot;라고 말합니다.
하지만 다형성을 이용한다면 동일한 작업을 수행할 수 있습니다. 두번째 질문은 보통 &quot;네 좋네요 근데 내가 왜 그렇게 해야하나요?&quot;이죠.
그에 대한 대답은, 앞서 우리가 공부했던 clean code 컨셉에 있습니다. 함수는 단 하나의 일만 수행하여야 합니다.
당신이 함수나 클래스에 <code>if</code>문을 쓴다면 그것은 그 함수나 클래스가 한가지 이상의 일을 수행하고 있다고 말하는 것과 같습니다.
기억하세요, 하나의 함수는 딱 하나의 일만 해야합니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">class Airplane {
  // ...
  getCruisingAltitude() {
    switch (this.type) {
      case &#x27;777&#x27;:
        return this.getMaxAltitude() - this.getPassengerCount();
      case &#x27;Air Force One&#x27;:
        return this.getMaxAltitude();
      case &#x27;Cessna&#x27;:
        return this.getMaxAltitude() - this.getFuelExpenditure();
    }
  }
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class Airplane {
  // ...
}

class Boeing777 extends Airplane {
  // ...
  getCruisingAltitude() {
    return this.getMaxAltitude() - this.getPassengerCount();
  }
}

class AirForceOne extends Airplane {
  // ...
  getCruisingAltitude() {
    return this.getMaxAltitude();
  }
}

class Cessna extends Airplane {
  // ...
  getCruisingAltitude() {
    return this.getMaxAltitude() - this.getFuelExpenditure();
  }
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>타입-체킹을 피하세요 (part 1)</h3><p>JavaScript는 타입이 정해져있지 않습니다. 이는 당신의 함수가 어떤 타입의 인자든 받을 수 있다는 것을 의미합니다.
이런 JavaScript의 자유로움 때문에 여러 버그가 발생했었고 이 때문에 당신의 함수에 타입-체킹을 시도 할 수도 있습니다.
하지만 타입-체킹 말고도 이러한 화를 피할 많은 방법들이 존재합니다. 첫번째 방법은 일관성 있는 API를 사용하는 것입니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function travelToTexas(vehicle) {
  if (vehicle instanceof Bicycle) {
    vehicle.pedal(this.currentLocation, new Location(&#x27;texas&#x27;));
  } else if (vehicle instanceof Car) {
    vehicle.drive(this.currentLocation, new Location(&#x27;texas&#x27;));
  }
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function travelToTexas(vehicle) {
  vehicle.move(this.currentLocation, new Location(&#x27;texas&#x27;));
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>타입-체킹을 피하세요 (part 2)</h3><p>당신이 문자열, 정수, 배열등 기본 자료형을 사용하고 다형성을 사용할 수 없을 때 여전히 타입-체킹이 필요하다고 느껴진다면
TypeScript를 도입하는 것을 고려해보는 것이 좋습니다. TypeScript는 표준 JavaScript 구문에 정적 타입을 제공하므로
일반 JavaScript의 대안으로 사용하기에 좋습니다. JavaScript에서 타입-체킹을 할 때 문제점은 가짜 <code>type-safety</code>
를 얻기위해 작성된 코드를 설명하기 위해서 많은 주석을 달아야한다는 점입니다. JavaScript로 코드를 작성할땐 깔끔하게 코드를 작성하고,
좋은 테스트 코드를 짜야하며 좋은 코드 리뷰를 해야합니다. 그러기 싫다면 그냥 TypeScript(이건 제가 말했듯이, 좋은 대체재입니다!)를 쓰세요.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function combine(val1, val2) {
  if (typeof val1 === &#x27;number&#x27; &amp;&amp; typeof val2 === &#x27;number&#x27; ||
      typeof val1 === &#x27;string&#x27; &amp;&amp; typeof val2 === &#x27;string&#x27;) {
    return val1 + val2;
  }
  
  throw new Error(&#x27;Must be of type String or Number&#x27;);
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function combine(val1, val2) {
  return val1 + val2;
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>과도한 최적화를 지양하세요</h3><p>최신 브라우저들은 런타임에 많은 최적화 작업을 수행합니다. 대부분 당신이 코드를 최적화 하는 것은 시간낭비일 가능성이 많습니다.
최적화가 부족한 곳이 어딘지를 알려주는 <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers">좋은 자료</a>가 여기 있습니다.
이것을 참조하여 최신 브라우저들이 최적화 해주지 않는 부분만 최적화를 해주는 것이 좋습니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">// 오래된 브라우저의 경우 캐시되지 않은 `list.length`를 통한 반복문은 높은 코스트를 가졌습니다.
// 그 이유는 `list.length`를 매번 계산해야만 했기 때문인데, 최신 브라우저에서는 이것이 최적화 되었습니다.
for (let i = 0, len = list.length; i &lt; len; i++) {
  // ...
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">for (let i = 0; i &lt; list.length; i++) {
  // ...
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>죽은 코드를 지우세요</h3><p>죽은 코드는 중복된 코드 만큼이나 좋지 않습니다. 죽은 코드는 당신의 코드에 남아있을 어떠한 이유도 없습니다.
호출되지 않는 코드가 있다면 그 코드는 지우세요! 그 코드가 여전히 필요해도 그 코드는 버전 히스토리에 안전하게
남아있을 것입니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function oldRequestModule(url) {
  // ...
}

function newRequestModule(url) {
  // ...
}

const req = newRequestModule;
inventoryTracker(&#x27;apples&#x27;, req, &#x27;www.inventory-awesome.io&#x27;);</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function newRequestModule(url) {
  // ...
}

const req = newRequestModule;
inventoryTracker(&#x27;apples&#x27;, req, &#x27;www.inventory-awesome.io&#x27;);</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h2><strong>객체와 자료구조(Objects and Data Structures)</strong></h2><h3>getter와 setter를 사용하세요</h3><p>JavaScript는 인터페이스와 타입을 가지고있지 않고 이러한 패턴을 적용하기가 힘듭니다.
왜냐하면 <code>public</code>이나 <code>private</code>같은 키워드가 없기 때문이죠.
그렇기 때문에 getter 및 setter를 사용하여 객체의 데이터에 접근하는 것이 객체의 속성을 찾는 것보다 훨씬 낫습니다.
&quot;왜요?&quot;라고 물으실 수도 있겠습니다. 왜 그런지에 대해서 몇 가지 이유를 두서없이 적어봤습니다.</p><ul><li>객체의 속성을 얻는 것 이상의 많은 것을 하고싶을 때, 코드에서 모든 접근자를 찾아 바꾸고 할 필요가 없습니다.</li><li><code>set</code>할때 검증로직을 추가하는 것이 코드를 더 간단하게 만듭니다.</li><li>내부용 API를 캡슐화 할 수 있습니다.</li><li><code>getting</code>과 <code>setting</code>할 때 로그를 찾거나 에러처리를 하기 쉽습니다.</li><li>클래스를 상속해서 디폴트 동작을 재정의할 수 있습니다.</li><li>서버에서 객체 속성을 받아올 때 lazy load 할 수 있습니다.</li></ul><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">class BankAccount {
  constructor() {
    this.balance = 1000;
  }
}

const bankAccount = new BankAccount();

// 신발을 구매할 때...
bankAccount.balance -= 100;</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class BankAccount {
  constructor(balance = 1000) {
	   this._balance = balance;
  }

  // getter/setter를 정의할 때 `get`, `set` 같은 접두사가 필요하지 않습니다.
  set balance(amount) {
      if (this.verifyIfAmountCanBeSetted(amount)) {
        this._balance = amount;
      }
    }
  
  get balance() {
    return this._balance;
  }

  verifyIfAmountCanBeSetted(val) {
    // ...
  }
}

const bankAccount = new BankAccount();
    
// 신발을 구매할 때...
bankAccount.balance -= shoesPrice;

// balance 값을 얻을 때
let balance = bankAccount.balance;</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>객체에 비공개 멤버를 만드세요</h3><p>클로져를 이용하면 가능합니다. (ES5 이하에서도)</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">const Employee = function(name) {
  this.name = name;
};

Employee.prototype.getName = function getName() {
  return this.name;
};

const employee = new Employee(&#x27;John Doe&#x27;);
console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe
delete employee.name;
console.log(`Employee name: ${employee.getName()}`); // Employee name: undefined</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function makeEmployee(name) {
  return {
    getName() {
      return name;
    },
  };
}

const employee = makeEmployee(&#x27;John Doe&#x27;);
console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe
delete employee.name;
console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h2><strong>클래스(Classes)</strong></h2><h3>단일 책임 원칙 (Single Responsibility Prinsiple, SRP)</h3><p>Clean Code에서 말하길 &quot;클래스를 수정 할 때는 수정 해야하는 이유가 2개 이상 있으면 안됩니다&quot;.
이것은 하나의 클래스에 많은 기능을 쑤셔넣는 것이나 다름 없습니다. 마치 비행기를 탈때 가방을 1개만 가지고 탈 수
있을 때 처럼 말이죠. 이 문제는 당신의 클래스가 개념적으로 응집되어 있지 않다는 것이고, 클래스를 바꿔야할 많은 이유가 됩니다.
클래스를 수정하는데 들이는 시간을 줄이는 것은 중요합니다. 왜냐면 하나의 클래스에 너무 많은 기능들이 있고
당신이 이 작은 기능들을 수정할 때 이 코드가 다른 모듈들에 어떠한 영향을 끼치는지 이해하기 어려울 수 있기 때문입니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">class UserSettings {
  constructor(user) {
    this.user = user;
  }

  changeSettings(settings) {
    if (this.verifyCredentials()) {
      // ...
    }
  }

  verifyCredentials() {
    // ...
  }
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class UserAuth {
  constructor(user) {
    this.user = user;
  }

  verifyCredentials() {
    // ...
  }
}


class UserSettings {
  constructor(user) {
    this.user = user;
    this.auth = new UserAuth(user);
  }

  changeSettings(settings) {
    if (this.auth.verifyCredentials()) {
      // ...
    }
  }
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>개방/폐쇄 원칙 (Open/Closed Principle, OCP)</h3><p>Bertrand Meyer에 말에 의하면 &quot;소프트웨어 개체(클래스, 모듈, 함수 등)는 확장을 위해 개방적이어야 하며 수정시엔
폐쇄적이어야 합니다.&quot; 이것에 의미는 무엇일까요? 이 원리는 기본적으로 사용자가 <code>.js</code> 소스 코드 파일을 열어 수동으로 조작하지 않고도
모듈의 기능을 확장하도록 허용해야한다고 말합니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = &#x27;ajaxAdapter&#x27;;
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = &#x27;nodeAdapter&#x27;;
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    if (this.adapter.name === &#x27;ajaxAdapter&#x27;) {
      return makeAjaxCall(url).then((response) =&gt; {
        // transform response and return
      });
    } else if (this.adapter.name === &#x27;httpNodeAdapter&#x27;) {
      return makeHttpCall(url).then((response) =&gt; {
        // transform response and return
      });
    }
  }
}

function makeAjaxCall(url) {
  // request and return promise
}

function makeHttpCall(url) {
  // request and return promise
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = &#x27;ajaxAdapter&#x27;;
  }

  request(url) {
    // request and return promise
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = &#x27;nodeAdapter&#x27;;
  }

  request(url) {
    // request and return promise
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    return this.adapter.request(url).then((response) =&gt; {
      // transform response and return
    });
  }
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>리스코프 치환 원칙 (Liskov Substitution Principle, LSP)</h3><p>이것은 매우 간단하지만 강력한 원칙입니다. 리스코프 원칙이란 자료형 S가 자료형 T의 하위형이라면,
프로그램이 갖추어야 할 속성들(정확성, 수행되는 작업 등)의 변경사항 없이, 자료형 T의 객체를 자료형 S의 객체로
교체(치환)할 수 있어야 한다는 원칙입니다.</p><p>이 원칙을 예를 들어 설명하자면 당신이 부모 클래스와 자식 클래스를 가지고 있을 때 베이스 클래스와 하위 클래스를
잘못된 결과 없이 서로 교환하여 사용할 수 있습니다. 여전히 이해가 안간다면 정사각형-직사각형 예제를 봅시다.
수학적으로 정사각형은 직사각형이지만 상속을 통해 &quot;is-a&quot; 관계를 사용하여 모델링한다면 문제가 발생합니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">class Rectangle {
  constructor() {
    this.width = 0;
    this.height = 0;
  }

  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }

  setWidth(width) {
    this.width = width;
  }

  setHeight(height) {
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  setWidth(width) {
    this.width = width;
    this.height = width;
  }

  setHeight(height) {
    this.width = height;
    this.height = height;
  }
}

function renderLargeRectangles(rectangles) {
  rectangles.forEach((rectangle) =&gt; {
    rectangle.setWidth(4);
    rectangle.setHeight(5);
    const area = rectangle.getArea(); // 정사각형일때 25를 리턴합니다. 하지만 20이어야 하는게 맞습니다.
    rectangle.render(area);
  });
}

const rectangles = [new Rectangle(), new Rectangle(), new Square()];
renderLargeRectangles(rectangles);</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class Shape {
  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Shape {
  constructor(length) {
    super();
    this.length = length;
  }

  getArea() {
    return this.length * this.length;
  }
}

function renderLargeShapes(shapes) {
  shapes.forEach((shape) =&gt; {
      const area = shape.getArea();
      shape.render(area);
    });
  }

const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];
renderLargeShapes(shapes);</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>인터페이스 분리 원칙 (Interface Segregation Principle, ISP)</h3><p>JavaScript는 인터페이스가 없기 때문에 다른 원칙들처럼 딱 맞게 적용할 수는 없습니다.
그러나, JavaScript에 타입 시스템이 없다 하더라도 중요하고 관계있는 원칙입니다.</p><p>ISP에 의하면 &quot;클라이언트는 사용하지 않는 인터페이스에 의존하도록 강요 받으면 안됩니다.&quot;
덕 타이핑 때문에 인터페이스는 JavaScript에서는 암시적인 계약일 뿐입니다.</p><p>JavaScript에서 이것을 보여주는 가장 좋은 예는 방대한 양의 설정 객체가 필요한 클래스입니다.
클라이언트가 방대한 양의 옵션을 설정하지 않는 것이 좋습니다. 왜냐하면 대부분의 경우 설정들이 전부 다 필요한 건 아니기 때문입니다.
설정을 선택적으로 할 수 있다면 &quot;무거운 인터페이스(fat interface)&quot;를 만드는 것을 방지할 수 있습니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.animationModule.setup();
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName(&#x27;body&#x27;),
  animationModule() {} // 우리는 대부분의 경우 DOM을 탐색할 때 애니메이션이 필요하지 않습니다.
  // ...
});</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.options = settings.options;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.setupOptions();
  }

  setupOptions() {
    if (this.options.animationModule) {
      // ...
    }
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName(&#x27;body&#x27;),
  options: {
    animationModule() {}
  }
});</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>의존성 역전 원칙 (Dependency Inversion Principle, DIP)</h3><p>이 원칙은 두가지 중요한 요소를 가지고 있습니다.</p><ol><li>상위 모듈은 하위 모듈에 종속되어서는 안됩니다. 둘 다 추상화에 의존해야 합니다.</li><li>추상화는 세부사항에 의존하지 않습니다. 세부사항은 추상화에 의해 달라져야 합니다.</li></ol><p>처음에는 이것을 이해하는데 어려울 수 있습니다. 하지만 만약 Angular.js로 작업해본적이 있다면
의존성 주입(Dependency Injection) 형태로 이 원리를 구현한 것을 보았을 것입니다.
DIP는 동일한 개념은 아니지만 상위 모듈이 하위 모듈의 세부사항을 알지 못하게 합니다.
이는 의존성 주입을 통해 달성할 수 있습니다. DI의 장점은 모듈 간의 의존성을 감소시키는 데에 있습니다.
모듈간의 의존성이 높을수록 코드를 리팩토링 하는데 어려워지고 이것은 매우 나쁜 개발 패턴들 중 하나입니다.</p><p>앞에서 설명한 것처럼 JavaScript에는 인터페이스가 없으므로 추상화에 의존하는 것은 암시적인 약속입니다.
이말인즉슨, 다른 객체나 클래스에 노출되는 메소드와 속성이 바로 암시적인 약속(추상화)가 된다는 것이죠.
아래 예제에서 암시적인 약속은 <code>InventoryTracker</code>에대한 모든 요청 모듈이 <code>requestItems</code> 메소드를
가질 것이라는 점입니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">class InventoryRequester {
  constructor() {
    this.REQ_METHODS = [&#x27;HTTP&#x27;];
  }

  requestItem(item) {
    // ...
  }
}

class InventoryTracker {
  constructor(items) {
    this.items = items;

    // 안좋은 이유: 특정 요청방법 구현에 대한 의존성을 만들었습니다.
    // requestItems는 한가지 요청방법을 필요로 합니다.
    this.requester = new InventoryRequester();
  }

  requestItems() {
    this.items.forEach(item =&gt; {
      this.requester.requestItem(item);
    });
  }
}

const inventoryTracker = new InventoryTracker([&#x27;apples&#x27;, &#x27;bananas&#x27;]);
inventoryTracker.requestItems();</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class InventoryTracker {
  constructor(items, requester) {
    this.items = items;
    this.requester = requester;
  }

  requestItems() {
    this.items.forEach(item =&gt; {
      this.requester.requestItem(item);
    });
  }
}

class InventoryRequesterV1 {
  constructor() {
    this.REQ_METHODS = [&#x27;HTTP&#x27;];
  }

  requestItem(item) {
    // ...
  }
}

class InventoryRequesterV2 {
  constructor() {
    this.REQ_METHODS = [&#x27;WS&#x27;];
  }

  requestItem(item) {
    // ...
  }
}

// 의존성을 외부에서 만들어 주입해줌으로써,
// 요청 모듈을 새롭게 만든 웹소켓 사용 모듈로 쉽게 바꿔 끼울 수 있게 되었습니다.
const inventoryTracker = new InventoryTracker([&#x27;apples&#x27;, &#x27;bananas&#x27;], new InventoryRequesterV2());
inventoryTracker.requestItems();</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>ES5의 함수보다 ES2015/ES6의 클래스를 사용하세요</h3><p>기존 ES5의 클래스에서 이해하기 쉬운 상속, 구성 및 메소드 정의를 하는 건 매우 어렵습니다.
매번 그런것은 아니지만 상속이 필요한 경우라면 클래스를 사용하는 것이 좋습니다.
하지만 당신이 크고 더 복잡한 객체가 필요한 경우가 아니라면 클래스보다 작은 함수를 사용하세요.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">const Animal = function(age) {
  if (!(this instanceof Animal)) {
    throw new Error(&quot;Instantiate Animal with `new`&quot;);
  }
    
  this.age = age;
};

Animal.prototype.move = function() {};

const Mammal = function(age, furColor) {
  if (!(this instanceof Mammal)) {
    throw new Error(&quot;Instantiate Mammal with `new`&quot;);
  }

  Animal.call(this, age);
  this.furColor = furColor;
};

Mammal.prototype = Object.create(Animal.prototype);
Mammal.prototype.constructor = Mammal;
Mammal.prototype.liveBirth = function liveBirth() {};

const Human = function(age, furColor, languageSpoken) {
  if (!(this instanceof Human)) {
    throw new Error(&quot;Instantiate Human with `new`&quot;);
  }

  Mammal.call(this, age, furColor);
  this.languageSpoken = languageSpoken;
};

Human.prototype = Object.create(Mammal.prototype);
Human.prototype.constructor = Human;
Human.prototype.speak = function speak() {};</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class Animal {
  constructor(age) {
    this.age = age;
  }

  move() { /* ... */ }
}

class Mammal extends Animal {
  constructor(age, furColor) {
    super(age);
    this.furColor = furColor;
  }

  liveBirth() { /* ... */ }
}

class Human extends Mammal {
  constructor(age, furColor, languageSpoken) {
    super(age, furColor);
    this.languageSpoken = languageSpoken;
  }

  speak() { /* ... */ }
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>메소드 체이닝을 사용하세요</h3><p>JavaScript에서 메소드 체이닝은 매우 유용한 패턴이며 jQuery나 Lodash같은 많은 라이브러리에서 이 패턴을 찾아볼 수 있습니다.
이는 코드를 간결하고 이해하기 쉽게 만들어줍니다.
이런 이유들로 메소드 체이닝을 쓰는 것을 권하고, 사용해본뒤 얼마나 코드가 깔끔해졌는지 꼭 확인 해보길 바랍니다.
클래스 함수에서 단순히 모든 함수의 끝에 &#x27;this&#x27;를 리턴해주는 것으로 클래스 메소드를 추가로 연결할 수 있습니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">class Car {
  constructor() {
    this.make = &#x27;Honda&#x27;;
    this.model = &#x27;Accord&#x27;;
    this.color = &#x27;white&#x27;;
  }

  setMake(make) {
    this.make = make;
  }

  setModel(model) {
    this.model = model;
  }

  setColor(color) {
    this.color = color;
  }

  save() {
    console.log(this.make, this.model, this.color);
  }
}

const car = new Car();
car.setColor(&#x27;pink&#x27;);
car.setMake(&#x27;Ford&#x27;);
car.setModel(&#x27;F-150&#x27;);
car.save();</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class Car {
  constructor() {
    this.make = &#x27;Honda&#x27;;
    this.model = &#x27;Accord&#x27;;
    this.color = &#x27;white&#x27;;
  }

  setMake(make) {
    this.make = make;
    // 메모: 체이닝을 위해 this를 리턴합니다.
    return this;
  }

  setModel(model) {
    this.model = model;
    // 메모: 체이닝을 위해 this를 리턴합니다.
    return this;
  }

  setColor(color) {
    this.color = color;
    // 메모: 체이닝을 위해 this를 리턴합니다.
    return this;
  }

  save() {
    console.log(this.make, this.model, this.color);
    // 메모: 체이닝을 위해 this를 리턴합니다.
    return this;
  }
}

const car = new Car()
  .setColor(&#x27;pink&#x27;)
  .setMake(&#x27;Ford&#x27;)
  .setModel(&#x27;F-150&#x27;)
  .save();</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>상속보단 조합(composition)을 사용하세요</h3><p>Gang of four의 <a href="https://en.wikipedia.org/wiki/Design_Patterns"><em>Design Patterns</em></a>에서 유명한
전략으로 당신은 가능하다면 상속보다는 조합을 사용해야 합니다. 상속을 사용했을 때 얻을 수 있는 이득보다 조합을 사용했을 때 얻을 수
있는 이득이 많기 때문입니다. 이 원칙의 요점은 당신이 계속 상속을 사용해서 코드를 작성하고자 할 때, 만약 조합을 이용하면
더 코드를 잘 짤 수 있지 않을까 생각해보라는 것에 있습니다. 때때로는 이것이 맞는 전략이기 때문이죠.</p><p>&quot;그럼 대체 상속을 언제 사용해야 되는 건가요?&quot;라고 물어 볼 수 있습니다. 이건 당신이 직면한 문제 상황에 달려있지만
조합보다 상속을 쓰는게 더 좋을 만한 예시를 몇 개 들어 보겠습니다.</p><ol><li>당신의 상속관계가 &quot;is-a&quot; 관계가 아니라 &quot;has-a&quot; 관계일 때 (사람-&gt;동물 vs. 유저-&gt;유저정보)</li><li>기반 클래스의 코드를 다시 사용할 수 있을 때 (인간은 모든 동물처럼 움직일 수 있습니다.)</li><li>기반 클래스를 수정하여 파생된 클래스 모두를 수정하고 싶을 때 (이동시 모든 동물이 소비하는 칼로리를 변경하고 싶을 때)</li></ol><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">class Employee {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  // ...
}

// 이 코드가 안좋은 이유는 Employees가 tax data를 &quot;가지고&quot; 있기 때문입니다.
// EmployeeTaxData는 Employee 타입이 아닙니다.
class EmployeeTaxData extends Employee {
  constructor(ssn, salary) {
    super();
    this.ssn = ssn;
    this.salary = salary;
  }

  // ...
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class EmployeeTaxData {
  constructor(ssn, salary) {
    this.ssn = ssn;
    this.salary = salary;
  }
  
  // ...
}

class Employee {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  setTaxData(ssn, salary) {
    this.taxData = new EmployeeTaxData(ssn, salary);
  }
  // ...
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h2><strong>테스트(Testing)</strong></h2><p>테스트는 배포하는 것보다 중요합니다. 테스트 없이 배포한다는 것은 당신이 짜놓은 코드가 언제든 오작동해도 이상하지 않다는 얘기와 같습니다.
테스트에 얼마나 시간을 투자할지는 당신이 함께 일하는 팀에 달려있지만 Coverage가 100%라는 것은 개발자들에게 높은 자신감과 안도감을 줍니다.
이 말은 훌륭한 테스트 도구를 보유해야 하는 것 뿐만 아니라 <a href="http://gotwarlost.github.io/istanbul/">훌륭한 Coverage 도구</a>를 사용해야한다는 것을 의미합니다.</p><p>테스트 코드를 작성하지 않는다는 것은 그 무엇도 변명이 될 수 없습니다. 여기 <a href="http://jstherightway.org/#testing-tools">훌륭하고 많은 JavaScript 테스트 프레임워크들</a>
이 있습니다. 당신의 팀의 기호에 맞는 프레임워크를 고르기만 하면 됩니다. 테스트 프레임워크를 골랐다면 이제부터는 팀의 목표를
모든 새로운 기능/모듈을 짤 때 테스트 코드를 작성하는 것으로 하세요. 만약 테스트 주도 개발 방법론(Test Driven Development, TDD)이 당신에게 맞는 방법이라면
그건 훌륭한 개발 방법이 될 수 있습니다. 그러나 중요한 것은 당신이 어떠한 기능을 개발하거나 코드를 리팩토링 할 때
당신이 정한 Coverage 목표를 달성하는 것에 있습니다.</p><h3>테스트 컵셉</h3><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">const assert = require(&#x27;assert&#x27;);

describe(&#x27;MakeMomentJSGreatAgain&#x27;, () =&gt; {
  it(&#x27;handles date boundaries&#x27;, () =&gt; {
    let date;

    date = new MakeMomentJSGreatAgain(&#x27;1/1/2015&#x27;);
    date.addDays(30);
    assert.equal(&#x27;1/31/2015&#x27;, date);

    date = new MakeMomentJSGreatAgain(&#x27;2/1/2016&#x27;);
    date.addDays(28);
    assert.equal(&#x27;02/29/2016&#x27;, date);

    date = new MakeMomentJSGreatAgain(&#x27;2/1/2015&#x27;);
    date.addDays(28);
    assert.equal(&#x27;03/01/2015&#x27;, date);
  });
});</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">const assert = require(&#x27;assert&#x27;);

describe(&#x27;MakeMomentJSGreatAgain&#x27;, () =&gt; {
  it(&#x27;handles 30-day months&#x27;, () =&gt; {
    const date = new MakeMomentJSGreatAgain(&#x27;1/1/2015&#x27;);
    date.addDays(30);
    assert.equal(&#x27;1/31/2015&#x27;, date);
  });

  it(&#x27;handles leap year&#x27;, () =&gt; {
    const date = new MakeMomentJSGreatAgain(&#x27;2/1/2016&#x27;);
    date.addDays(28);
    assert.equal(&#x27;02/29/2016&#x27;, date);
  });

  it(&#x27;handles non-leap year&#x27;, () =&gt; {
    const date = new MakeMomentJSGreatAgain(&#x27;2/1/2015&#x27;);
    date.addDays(28);
    assert.equal(&#x27;03/01/2015&#x27;, date);
  });
});</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h2><strong>동시성(Concurrency)</strong></h2><h3>Callback 대신 Promise를 사용하세요</h3><p>Callback은 깔끔하지 않습니다. 그리고 엄청나게 많은 중괄호 중첩을 만들어 냅니다.
ES2015/ES6에선 Promise가 내장되어 있습니다. 이걸 쓰세요!</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">require(&#x27;request&#x27;).get(&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;, (requestErr, response) =&gt; {
  if (requestErr) {
    console.error(requestErr);
  } else {
    require(&#x27;fs&#x27;).writeFile(&#x27;article.html&#x27;, response.body, (writeErr) =&gt; {
      if (writeErr) {
        console.error(writeErr);
      } else {
        console.log(&#x27;File written&#x27;);
      }
    });
  }
});</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">require(&#x27;request-promise&#x27;).get(&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;)
  .then((response) =&gt; {
    return require(&#x27;fs-promise&#x27;).writeFile(&#x27;article.html&#x27;, response);
  })
  .then(() =&gt; {
    console.log(&#x27;File written&#x27;);
  })
  .catch((err) =&gt; {
    console.error(err);
  });</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>Async/Await은 Promise보다 더욱 깔끔합니다</h3><p>Promise도 Callback에 비해 정말 깔끔하지만 ES2017/ES8에선 async와 await이 있습니다.
이들은 Callback에대한 더욱 깔끔한 해결책을 줍니다. 오직 필요한 것은 함수앞에 <code>async</code>를 붙이는 것 뿐입니다.
그러면 함수를 논리적으로 연결하기위해 더이상 <code>then</code>을 쓰지 않아도 됩니다. 
만약 당신이 ES2017/ES8 사용할 수 있다면 이것을 사용하세요!</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">require(&#x27;request-promise&#x27;).get(&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;)
  .then(response =&gt; {
    return require(&#x27;fs-promise&#x27;).writeFile(&#x27;article.html&#x27;, response);
  })
  .then(() =&gt; {
    console.log(&#x27;File written&#x27;);
  })
  .catch(err =&gt; {
    console.error(err);
  })</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">async function getCleanCodeArticle() {
  try {
    const response = await require(&#x27;request-promise&#x27;).get(&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;);
    await require(&#x27;fs-promise&#x27;).writeFile(&#x27;article.html&#x27;, response);
    console.log(&#x27;File written&#x27;);
  } catch(err) {
    console.error(err);
  }
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h2><strong>에러 처리(Error Handling)</strong></h2><p>에러를 뱉는다는 것은 좋은 것입니다! 즉, 프로그램에서 무언가가 잘못되었을 때 런타임에서 성공적으로 확인되면 
현재 스택에서 함수 실행을 중단하고 (노드에서) 프로세스를 종료하고 스택 추적으로 콘솔에서 사용자에게 
그 이유를 알려줍니다.</p><h3>단순히 에러를 확인만 하지마세요</h3><p>단순히 에러를 확인하는 것만으로 그 에러가 해결되거나 대응 할 수 있게 되는 것은 아닙니다.
<code>console.log</code>를 통해 콘솔에 로그를 기록하는 것은 에러 로그를 잃어버리기 쉽기 때문에 좋은 방법이 아닙니다.
만약에 <code>try/catch</code>로 어떤 코드를 감쌌다면 그건 당신이 그 코드에 어떤 에러가 날지도 모르기 때문에 감싼 것이므로
그에대한 계획이 있거나 어떠한 장치를 해야합니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">try {
  functionThatMightThrow();
} catch (error) {
  console.log(error);
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">try {
  functionThatMightThrow();
} catch (error) {
  // 첫번째 방법은 console.error를 이용하는 것입니다. 이건 console.log보다 조금 더 알아채기 쉽습니다.
  console.error(error);
  // 다른 방법은 유저에게 알리는 방법입니다.
  notifyUserOfError(error);
  // 또 다른 방법은 서비스 자체에 에러를 기록하는 방법입니다.
  reportErrorToService(error);
  // 혹은 그 어떤 방법이 될 수 있습니다.
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>Promise가 실패된 것을 무시하지 마세요</h3><p>위의 원칙과 같은 이유입니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">getdata()
.then(data =&gt; {
  functionThatMightThrow(data);
})
.catch(error =&gt; {
  console.log(error);
});</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">getdata()
.then(data =&gt; {
  functionThatMightThrow(data);
})
.catch(error =&gt; {
  // 첫번째 방법은 console.error를 이용하는 것입니다. 이건 console.log보다 조금 더 알아채기 쉽습니다.
  console.error(error);
  // 다른 방법은 유저에게 알리는 방법입니다.
  notifyUserOfError(error);
  // 또 다른 방법은 서비스 자체에 에러를 기록하는 방법입니다.
  reportErrorToService(error);
  // 혹은 그 어떤 방법이 될 수 있습니다.
});</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h2><strong>포맷팅(Formatting)</strong></h2><p>포맷팅은 주관적입니다. 여기에 있는 많은 규칙과 마찬가지로 따르기 쉬운 규칙들이 있습니다.
여기서 알아야 할 것은 포맷팅에 대해 과도하게 신경쓰는 것은 의미없다는 것입니다.
포맷팅 체크를 자동으로 해주는 <a href="http://standardjs.com/rules.html">많은 도구들</a>이 있기 때문입니다.
이중 하나를 골라 사용하세요. 개발자들끼리 포맷팅에대해 논쟁하는 것만큼 시간과 돈을 낭비하는 것이 없습니다.</p><p>자동으로 서식을 교정해주는 것(들여쓰기, 탭이냐 스페이스냐, 작은 따옴표냐 큰따옴표냐)에 해당하지 않는 사항에
대해서는 몇가지 지침을 따르는 것이 좋습니다.</p><h3>일관된 대소문자를 사용하세요</h3><p>JavaScript에는 정해진 타입이 없기 때문에 대소문자를 구분하는 것으로 당신의 변수나 함수명 등에서 많은 것을 알 수 있습니다.
이 규칙 또한 주관적이기 때문에 당신이 팀이 선택한 규칙들을 따르세요 중요한건 항상 일관성 있게 사용해야 한다는 것입니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">const DAYS_IN_WEEK = 7;
const daysInMonth = 30;

const songs = [&#x27;Back In Black&#x27;, &#x27;Stairway to Heaven&#x27;, &#x27;Hey Jude&#x27;];
const Artists = [&#x27;ACDC&#x27;, &#x27;Led Zeppelin&#x27;, &#x27;The Beatles&#x27;];

function eraseDatabase() {}
function restore_database() {}

class animal {}
class Alpaca {}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">const DAYS_IN_WEEK = 7;
const DAYS_IN_MONTH = 30;

const songs = [&#x27;Back In Black&#x27;, &#x27;Stairway to Heaven&#x27;, &#x27;Hey Jude&#x27;];
const artists = [&#x27;ACDC&#x27;, &#x27;Led Zeppelin&#x27;, &#x27;The Beatles&#x27;];

function eraseDatabase() {}
function restoreDatabase() {}

class Animal {}
class Alpaca {}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>함수 호출자와 함수 피호출자는 가깝게 위치시키세요</h3><p>어떤 함수가 다른 함수를 호출하면 그 함수들은 소스 파일 안에서 서로 수직으로 근접해 있어야 합니다.
이상적으로는 함수 호출자를 함수 피호출자 바로 위에 위치시켜야 합니다. 우리는 코드를 읽을때 신문을 읽듯
위에서 아래로 읽기 때문에 코드를 작성 할 때도 읽을 때를 고려하여 작성 해야합니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">class PerformanceReview {
  constructor(employee) {
    this.employee = employee;
  }

  lookupPeers() {
    return db.lookup(this.employee, &#x27;peers&#x27;);
  }

  lookupManager() {
    return db.lookup(this.employee, &#x27;manager&#x27;);
  }

  getPeerReviews() {
    const peers = this.lookupPeers();
    // ...
  }

  perfReview() {
    this.getPeerReviews();
    this.getManagerReview();
    this.getSelfReview();
  }

  getManagerReview() {
    const manager = this.lookupManager();
  }

  getSelfReview() {
    // ...
  }
}

const review = new PerformanceReview(user);
review.perfReview();</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">class PerformanceReview {
  constructor(employee) {
    this.employee = employee;
  }

  perfReview() {
    this.getPeerReviews();
    this.getManagerReview();
    this.getSelfReview();
  }

  getPeerReviews() {
    const peers = this.lookupPeers();
    // ...
  }

  lookupPeers() {
    return db.lookup(this.employee, &#x27;peers&#x27;);
  }

  getManagerReview() {
    const manager = this.lookupManager();
  }

  lookupManager() {
    return db.lookup(this.employee, &#x27;manager&#x27;);
  }

  getSelfReview() {
    // ...
  }
}

const review = new PerformanceReview(employee);
review.perfReview();</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h2><strong>주석(Comments)</strong></h2><h3>주석은 단지 그 로직이 복잡하다는 것을 말 할 뿐입니다</h3><p>주석을 다는것은 사과해야할 일이며 필수적인 것이 아닙니다. 좋은 코드는 <em>코드 자체</em>로 말합니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">function hashIt(data) {
  // 이건 해쉬입니다.
  let hash = 0;

  // lengh는 data의 길이입니다.
  const length = data.length;

  // 데이터의 문자열 개수만큼 반복문을 실행합니다.
  for (let i = 0; i &lt; length; i++) {
    // 문자열 코드를 얻습니다.
    const char = data.charCodeAt(i);
    // 해쉬를 만듭니다.
    hash = ((hash &lt;&lt; 5) - hash) + char;
    // 32-bit 정수로 바꿉니다.
    hash &amp;= hash;
  }
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function hashIt(data) {
  let hash = 0;
  const length = data.length;

  for (let i = 0; i &lt; length; i++) {
    const char = data.charCodeAt(i);
    hash = ((hash &lt;&lt; 5) - hash) + char;

    // 32-bit 정수로 바꿉니다.
    hash &amp;= hash;
  }
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>주석으로 된 코드를 남기지 마세요</h3><p>버전 관리 도구가 존재하기 때문에 코드를 주석으로 남길 이유가 없습니다.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">doStuff();
// doOtherStuff();
// doSomeMoreStuff();
// doSoMuchStuff();</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">doStuff();</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>코드 기록을 주석으로 남기지 마세요</h3><p>버전 관리 도구를 이용해야하는 것을 꼭 기억하세요. 죽은 코드도 불필요한 설명도 특히 코드의 기록에 대한 주석도
필요하지 않습니다. 코드의 기록에 대해 보고 싶다면 <code>git log</code>를 사용하세요!</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">/**
 * 2016-12-20: 모나드 제거했음, 이해는 되지 않음 (RM)
 * 2016-10-01: 모나드 쓰는 로직 개선 (JP)
 * 2016-02-03: 타입체킹 하는부분 제거 (LI)
 * 2015-03-14: 버그 수정 (JR)
 */
function combine(a, b) {
  return a + b;
}</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">function combine(a, b) {
  return a + b;
}</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h3>코드의 위치를 설명하지 마세요</h3><p>이건 정말 쓸데 없습니다. 적절한 들여쓰기와 포맷팅을 하고 함수와 변수의 이름에 의미를 부여하세요.</p><p><strong>안좋은 예:</strong></p><pre><code class="language-javascript">////////////////////////////////////////////////////////////////////////////////
// 스코프 모델 정의
////////////////////////////////////////////////////////////////////////////////
$scope.model = {
  menu: &#x27;foo&#x27;,
  nav: &#x27;bar&#x27;
};

////////////////////////////////////////////////////////////////////////////////
// actions 설정
////////////////////////////////////////////////////////////////////////////////
const actions = function() {
  // ...
};</code></pre><p><strong>좋은 예:</strong></p><pre><code class="language-javascript">$scope.model = {
  menu: &#x27;foo&#x27;,
  nav: &#x27;bar&#x27;
};

const actions = function() {
  // ...
};</code></pre><p><strong><a href="#목차">⬆ 상단으로</a></strong></p><h2>번역(Translation)</h2><p>다른 언어로도 읽을 수 있습니다:</p><ul><li><img alt="br" src="https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Brazil.png"/> <strong>Brazilian Portuguese</strong>: <a href="https://github.com/fesnt/clean-code-javascript">fesnt/clean-code-javascript</a></li><li><img alt="cn" src="https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/China.png"/> <strong>Chinese</strong>: <a href="https://github.com/alivebao/clean-code-js">alivebao/clean-code-js</a></li><li><img alt="de" src="https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Germany.png"/> <strong>German</strong>: <a href="https://github.com/marcbruederlin/clean-code-javascript">marcbruederlin/clean-code-javascript</a></li><li><img alt="kr" src="https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/South-Korea.png"/> <strong>Korean</strong>: <a href="https://github.com/qkraudghgh/clean-code-javascript-ko">qkraudghgh/clean-code-javascript-ko</a></li><li><img alt="ru" src="https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Russia.png"/> <strong>Russian</strong>: <a href="https://github.com/BoryaMogila/clean-code-javascript-ru/">BoryaMogila/clean-code-javascript-ru/</a></li></ul><p><strong><a href="#목차">⬆ 상단으로</a></strong></p></div><div class="post__DisqusContainer-sc-18d9za3-1 dSPDsA"><div id="disqus_thread"></div></div></div></div><footer class="Footer__Container-sc-121sa8t-0 jThIxF"><i class="fas fa-arrow-left fa-2x Footer__PrevIcon-sc-121sa8t-2 ilNniD"></i><p>2018 Gyumin</p><i class="fas fa-arrow-up fa-2x Footer__Icon-sc-121sa8t-1 kRNjcA"></i></footer></div></div><div id="__next-error"></div><script>
          __NEXT_DATA__ = {"props":{"pageProps":{"title":"clean-code-javascript-ko","decoded":"# clean-code-javascript\n\n* Updated date 2017.1.31\n* 현재 원문의 [ac6a51d](https://github.com/ryanmcdermott/clean-code-javascript/commit/ac6a51d640064ec4ac6cada7af477df8967dd193)\n까지 반영되어 있습니다.\n\n## 목차\n  1. [소개(Introduction)](#소개introduction)\n  2. [변수(Variables)](#변수variables)\n  3. [함수(Functions)](#함수functions)\n  4. [객체와 자료구조(Objects and Data Structures)](#객체와-자료구조objects-and-data-structures)\n  5. [클래스(Classes)](#클래스classes)\n  6. [테스트(Testing)](#테스트testing)\n  7. [동시성(Concurrency)](#동시성concurrency)\n  8. [에러 처리(Error Handling)](#에러-처리error-handling)\n  9. [포맷팅(Formatting)](#포맷팅formatting)\n  10. [주석(Comments)](#주석comments)\n  11. [번역(Translation)](#번역translation)\n  \n## 소개(Introduction)\n![코드를 읽을 때 소리 지르는 숫자로 소프트웨어 품질을 추정하는 유머 사진](http://www.osnews.com/images/comics/wtfm.jpg)\n\n이 글은 소프트웨어 방법론에 관한 책들 중 Robert C. Martin's의 책인 [*Clean Code*](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)에 있는 내용을 JavaScript 언어에 적용시켜 적은 글 입니다.\n이 글은 단순히 Style Guide가 아니라 JavaScript로 코드를 작성할때 읽기 쉽고, 재사용 가능하며 리팩토링 가능하게끔 작성하도록 도와줍니다.\n\n여기 있는 모든 원칙이 엄격히 지켜져야하는 것은 아니며, 보편적으로 통용되는 원칙은 아닙니다. 이것들은 지침일 뿐이며 `Clean Code`의 저자가 수년간 경험한 내용을 바탕으로 정리한 것입니다.\n\n소프트웨어 엔지니어링 역사는 50년을 조금 넘겼지만 우리는 아직도 많은 것들을 배우고 있습니다.\n그리고 소프트웨어 아키텍쳐가 건축설계 만큼이나 오래되었을때 우리는 아래 규칙들보다 더 엄격한 규칙들을 따라야 할지도 모릅니다.\n하지만 지금 당장은 이 가이드 라인을 당신과 당신 팀이 작성하는 JavaScript 코드의 품질을 평가하는 기준으로 삼으세요.\n\n한가지 더 덧붙이자면, 이 원칙들을 알게된다해서 당장 더 나은 개발자가 되는 것은 아니며 코드를 작성할 때 \n실수를 하지 않게 해주는 것은 아닙니다. 훌륭한 도자기들이 처음엔 말랑한 점토부터 시작하듯이 모든 코드들은 처음부터 완벽할 수 없습니다.\n하지만 당신은 팀원들과 같이 코드를 리뷰하며 점점 완벽하게 만들어가야 합니다. 당신이 처음 작성한 코드를 고칠 때 절대로 자신을 질타하지 마세요.\n대신 코드를 부수고 더 나은 코드를 만드세요!\n\n## **변수(Variables)**\n### 의미있고 발음하기 쉬운 변수 이름을 사용하세요\n\n**안좋은 예:**\n```javascript\nconst yyyymmdstr = moment().format('YYYY/MM/DD');\n```\n\n**좋은 예:**\n```javascript\nconst currentDate = moment().format('YYYY/MM/DD');\n```\n**[⬆ 상단으로](#목차)**\n\n### 동일한 유형의 변수에 동일한 어휘를 사용하세요\n\n**안좋은 예:**\n```javascript\ngetUserInfo();\ngetClientData();\ngetCustomerRecord();\n```\n\n**좋은 예:**\n```javascript\ngetUser();\n```\n**[⬆ 상단으로](#목차)**\n\n### 검색가능한 이름을 사용하세요\n우리는 작성할 코드보다 읽을 코드가 더 많습니다. 그렇기 때문에 코드를 읽기 쉽고 검색 가능하게 작성해야 합니다.\n그렇지 않으면 여러분의 코드를 이해하려고 하는 사람들에게 큰 어려움을 줍니다.\n검색가능한 이름으로 만드세요.\n[buddy.js](https://github.com/danielstjules/buddy.js) 그리고\n[ESLint](https://github.com/eslint/eslint/blob/660e0918933e6e7fede26bc675a0763a6b357c94/docs/rules/no-magic-numbers.md)\n와 같은 도구들이 이름이 정해져있지 않은 상수들을 발견하고 고칠 수 있게 도와줍니다.\n\n**안좋은 예:**\n```javascript\n// 대체 86400000 무엇을 의미하는 걸까요?\nsetTimeout(blastOff, 86400000);\n```\n\n**좋은 예**\n```javascript\n// 대문자로 `const` 전역 변수를 선언하세요\nconst MILLISECONDS_IN_A_DAY = 86400000;\nsetTimeout(blastOff, MILLISECONDS_IN_A_DAY);\n```\n**[⬆ 상단으로](#목차)**\n\n### 의도를 나타내는 변수들을 사용하세요\n**안좋은 예:**\n```javascript\nconst address = 'One Infinite Loop, Cupertino 95014';\nconst cityZipCodeRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/;\nsaveCityZipCode(address.match(cityZipCodeRegex)[1], address.match(cityZipCodeRegex)[2]);\n```\n**좋은 예:**\n```javascript\nconst address = 'One Infinite Loop, Cupertino 95014';\nconst cityZipCodeRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/;\nconst [, city, zipCode] = address.match(cityZipCodeRegex) || [];\nsaveCityZipCode(city, zipCode);\n```\n**[⬆ 상단으로](#목차)**\n\n### 자신만 알아볼 수 있는 작명을 피하세요\n명시적인 것이 암시적인 것보다 좋습니다.\n\n**안좋은 예:**\n```javascript\nconst locations = ['서울', '인천', '수원'];\nlocations.forEach(l =\u003e {\n  doStuff();\n  doSomeOtherStuff();\n  // ...\n  // ...\n  // ...\n  // 잠깐, `l`은 또 뭘까요?\n  dispatch(l);\n});\n```\n\n**좋은 예:**\n```javascript\nconst locations = ['서울', '인천', '수원'];\nlocations.forEach(location =\u003e {\n  doStuff();\n  doSomeOtherStuff();\n  // ...\n  // ...\n  // ...\n  dispatch(location);\n});\n```\n**[⬆ 상단으로](#목차)**\n\n### 문맥상 필요없는 것들을 쓰지 마세요\n\n**안좋은 예:**\n```javascript\nconst Car = {\n  carMake: 'BMW',\n  carModel: 'M3',\n  carColor: '파란색'\n};\n\nfunction paintCar(car) {\n  car.carColor = '빨간색';\n}\n```\n\n**좋은 예:**\n```javascript\nconst Car = {\n  make: 'BMW',\n  model: 'M3',\n  color: '파란색'\n};\n\nfunction paintCar(car) {\n  car.color = '빨간색';\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 기본 매개변수가 short circuiting 트릭이나 조건문 보다 깔끔합니다\n기본 매개변수는 종종 short circuiting 트릭보다 깔끔합니다. 기본 매개변수는 매개변수가 `undefined`일때만 \n적용됩니다. `''`, `\"\"`, `false`, `null`, `0`, `NaN` 같은 `falsy`한 값들은 기본 매개변수가 적용되지 않습니다.\n\n**안좋은 예:**\n```javascript\nfunction createMicrobrewery(name) {\n  const breweryName = name || 'Hipster Brew Co.';\n  // ...\n}\n```\n\n**좋은 예:**\n```javascript\nfunction createMicrobrewery(name = 'Hipster Brew Co.') {\n  // ...\n}\n```\n**[⬆ 상단으로](#목차)**\n\n## **함수(Functions)**\n### 함수 인자는 2개 이하가 이상적입니다\n매개변수의 개수를 제한 하는 것은 함수 테스팅을 쉽게 만들어 주기 때문에 중요합니다. 만약 매개변수가 3개 이상일 경우엔\n테스트 해야하는 경우의 수가 많아지고 각기 다른 인수들로 여러 사례들을 테스트 해야합니다.\n\n1개나 2개의 인자를 가지고 있는 것이 가장 이상적인 케이스입니다.\n그리고 3개의 인자는 가능한 피해야합니다. 그것보다 더 많다면 통합되어야합니다.\n만약 당신이 2개 이상의 인자를 가진 함수를 사용한다면 그 함수에게 너무 많은 역할을 하게 만든 것입니다.\n그렇지 않은 경우라면 대부분의 경우 상위 객체는 1개의 인자만으로 충분합니다.\n\nJavaScript를 사용할 때 많은 보일러플레이트 없이 바로 객체를 만들 수 있습니다.\n그러므로 당신이 만약 많은 인자들을 사용해야 한다면 객체를 이용할 수 있습니다.\n\n함수가 기대하는 속성을 좀더 명확히 하기 위해서 es6의 비구조화(destructuring) 구문을 사용할 수 있고\n이 구문에는 몇가지 장점이 있습니다.\n\n1. 어떤 사람이 그 함수의 시그니쳐(인자의 타입, 반환되는 값의 타입 등)를 볼 때 어떤 속성이 사용되는지\n즉시 알 수 있습니다.\n2. 또한 비구조화는 함수에 전달된 인수 객체의 지정된 기본타입 값을 복제하며 이는 사이드이펙트가\n일어나는 것을 방지합니다. 참고로 인수 객체로부터 비구조화된 객체와 배열은 복제되지 않습니다.\n3. Linter를 사용하면 사용하지않는 인자에 대해 경고해주거나 비구조화 없이 코드를 짤 수 없게 할 수 있습니다.\n\n\n\n**안좋은 예:**\n```javascript\nfunction createMenu(title, body, buttonText, cancellable) {\n  // ...\n}\n```\n\n**좋은 예:**\n```javascript\nfunction createMenu({ title, body, buttonText, cancellable }) {\n  // ...\n}\n\ncreateMenu({\n  title: 'Foo',\n  body: 'Bar',\n  buttonText: 'Baz',\n  cancellable: true\n});\n```\n**[⬆ 상단으로](#목차)**\n\n### 함수는 하나의 행동만 해야합니다\n이것은 소프트웨어 엔지니어링에서 가장 중요한 규칙입니다. 함수가 1개 이상의 행동을 한다면 작성하는 것도, 테스트하는 것도, 이해하는 것도 어려워집니다.\n당신이 하나의 함수에 하나의 행동을 정의하는 것이 가능해진다면 함수는 좀 더 고치기 쉬워지고 코드들은 읽기 쉬워질 것입니다.\n많은 원칙들 중 이것만 알아간다 하더라도 당신은 많은 개발자들을 앞설 수 있습니다.\n\n**안좋은 예:**\n```javascript\nfunction emailClients(clients) {\n  clients.forEach(client =\u003e {\n    const clientRecord = database.lookup(client);\n    if (clientRecord.isActive()) {\n      email(client);\n    }\n  });\n}\n```\n\n**좋은 예:**\n```javascript\nfunction emailClients(clients) {\n  clients\n    .filter(isClientActive)\n    .forEach(email);\n}\n\nfunction isClientActive(client) {\n  const clientRecord = database.lookup(client);\n  return clientRecord.isActive();\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 함수명은 함수가 무엇을 하는지 알 수 있어야 합니다\n\n**안좋은 예:**\n```javascript\nfunction AddToDate(date, month) {\n  // ...\n}\n\nconst date = new Date();\n\n// 뭘 추가하는 건지 이름만 보고 알아내기 힘듭니다.\nAddToDate(date, 1);\n```\n\n**좋은 예:**\n```javascript\nfunction AddMonthToDate(date, month) {\n  // ...\n}\n\nconst date = new Date();\nAddMonthToDate(date, 1);\n```\n**[⬆ 상단으로](#목차)**\n\n### 함수는 단일 행동을 추상화 해야합니다\n추상화된 이름이 여러 의미를 내포하고 있다면 그 함수는 너무 많은 일을 하게끔 설계된 것입니다.\n함수들을 나누어서 재사용가능하고 테스트하기 쉽게 만드세요.\n\n**안좋은 예:**\n```javascript\nfunction parseBetterJSAlternative(code) {\n  const REGEXES = [\n    // ...\n  ];\n\n  const statements = code.split(' ');\n  const tokens = [];\n  REGEXES.forEach(REGEX =\u003e {\n    statements.forEach(statement =\u003e {\n      // ...\n    });\n  });\n\n  const ast = [];\n  tokens.forEach(token =\u003e {\n    // lex...\n  });\n\n  ast.forEach(node =\u003e {\n    // parse...\n  });\n}\n```\n\n**좋은 예:**\n```javascript\nfunction tokenize(code) {\n  const REGEXES = [\n    // ...\n  ];\n\n  const statements = code.split(' ');\n  const tokens = [];\n  REGEXES.forEach(REGEX =\u003e {\n    statements.forEach(statement =\u003e {\n      tokens.push( /* ... */ );\n    });\n  });\n\n  return tokens;\n}\n\nfunction lexer(tokens) {\n  const ast = [];\n  tokens.forEach(token =\u003e {\n    ast.push( /* ... */ );\n  });\n\n  return ast;\n}\n\nfunction parseBetterJSAlternative(code) {\n  const tokens = tokenize(code);\n  const ast = lexer(tokens);\n  ast.forEach(node =\u003e {\n    // parse...\n  });\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 중복된 코드를 작성하지 마세요\n중복된 코드를 작성하지 않기위해 최선을 다하세요.\n중복된 코드가 있다는 것은 어떤 로직을 수정해야 할 일이 생겼을 때 수정 해야할 코드가 한 곳 이상이라는 것을 뜻합니다.\n\n만약 당신이 레스토랑을 운영하면서 토마토나 양파, 마늘, 고추같은 것들의 재고관리를 해야한다고 생각해보세요.\n재고가 적혀있는 종이가 여러장 있다면 토마토나 양파의 재고가 변동되었을 때 재고가 적혀있는 모든 종이를 수정해야 합니다.\n만약 재고를 관리하는 종이가 한 장이었다면 한 장의 재고 목록만 수정하면 됐겠죠!\n\n종종 코드를 살펴보면 사소한 몇몇의 차이점 때문에 중복된 코드를 작성한 경우가 있고\n이런 차이점들은 대부분 똑같은 일을 하는 분리된 함수들을 갖도록 강요합니다.\n즉 중복 코드를 제거한다는 것은 하나의 함수 / 모듈 / 클래스를 사용하여 이 여러 가지 사소한 차이점을 처리 할 수 있는\n추상화를 만드는 것을 의미합니다.\n\n그리고 추상화 할 부분이 남아있는 것은 위험하기때문에 *클래스* 섹션에 제시된 여러 원칙들을 따라야 합니다.\n잘 추상화 하지 못한 코드는 중복된 코드보다 나쁠 수 있으므로 조심하세요. 즉 추상화를 잘 할 수 있다면\n그렇게 하라는 말입니다. 코드의 중복을 피한다면 여러분이 원할 때 언제든 한 곳만 수정해도 다른 모든 코드에\n반영되게 할 수 있습니다.\n\n**안좋은 예:**\n```javascript\nfunction showDeveloperList(developers) {\n  developers.forEach(developers =\u003e {\n    const expectedSalary = developer.calculateExpectedSalary();\n    const experience = developer.getExperience();\n    const githubLink = developer.getGithubLink();\n    const data = {\n      expectedSalary,\n      experience,\n      githubLink\n    };\n\n    render(data);\n  });\n}\n\nfunction showManagerList(managers) {\n  managers.forEach(manager =\u003e {\n    const expectedSalary = manager.calculateExpectedSalary();\n    const experience = manager.getExperience();\n    const portfolio = manager.getMBAProjects();\n    const data = {\n      expectedSalary,\n      experience,\n      portfolio\n    };\n\n    render(data);\n  });\n}\n```\n\n**좋은 예:**\n```javascript\nfunction showEmployeeList(employees) {\n  employees.forEach((employee) =\u003e {\n    const expectedSalary = employee.calculateExpectedSalary();\n    const experience = employee.getExperience();\n\n    let portfolio = employee.getGithubLink();\n\n    if (employee.type === 'manager') {\n      portfolio = employee.getMBAProjects();\n    }\n\n    const data = {\n      expectedSalary,\n      experience,\n      portfolio\n    };\n\n    render(data);\n  });\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### Object.assign을 사용해 기본 객체를 만드세요\n\n**안좋은 예:**\n```javascript\nconst menuConfig = {\n  title: null,\n  body: 'Bar',\n  buttonText: null,\n  cancellable: true\n};\n\nfunction createMenu(config) {\n  config.title = config.title || 'Foo';\n  config.body = config.body || 'Bar';\n  config.buttonText = config.buttonText || 'Baz';\n  config.cancellable = config.cancellable === undefined ? config.cancellable : true;\n\n}\n\ncreateMenu(menuConfig);\n```\n\n**좋은 예:**\n```javascript\nconst menuConfig = {\n  title: 'Order',\n  // 유저가 'body' key의 value를 정하지 않았다.\n  buttonText: 'Send',\n  cancellable: true\n};\n\nfunction createMenu(config) {\n  config = Object.assign({\n    title: 'Foo',\n    body: 'Bar',\n    buttonText: 'Baz',\n    cancellable: true\n  }, config);\n\n  // config는 이제 다음과 동일합니다: {title: \"Order\", body: \"Bar\", buttonText: \"Send\", cancellable: true}\n  // ...\n}\n\ncreateMenu(menuConfig);\n```\n**[⬆ 상단으로](#목차)**\n\n### 매개변수로 플래그를 사용하지 마세요\n플래그를 사용하는 것 자체가 그 함수가 한가지 이상의 역할을 하고 있다는 것을 뜻합니다.\nboolean 기반으로 함수가 실행되는 코드가 나뉜다면 함수를 분리하세요.\n\n**안좋은 예:**\n```javascript\nfunction createFile(name, temp) {\n  if (temp) {\n    fs.create(`./temp/${name}`);\n  } else {\n    fs.create(name);\n  }\n}\n```\n\n**좋은 예:**\n```javascript\nfunction createFile(name) {\n  fs.create(name);\n}\n\nfunction createTempFile(name) {\n  createFile(`./temp/${name}`);\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 사이드 이펙트를 피하세요 (part 1)\n함수는 값을 받아서 어떤 일을 하거나 값을 리턴할때 사이드 이팩트를 만들어냅니다.\n사이드 이팩트는 파일에 쓰여질 수도 있고, 전역 변수를 수정할 수 있으며, 실수로 모든 돈을 다른 사람에게 보낼 수도 있습니다.\n\n당신은 때때로 프로그램에서 사이드 이팩트를 만들어야 할 때가 있습니다. 아까 들었던 예들 중 하나인 파일작성을 할 때와 같이 말이죠.\n이 때 여러분이 해야할 일은 파일 작성을 하는 한 개의 함수를 만드는 일 입니다. 파일을 작성하는 함수나 클래스가\n여러개 존재하면 안됩니다. 반드시 하나만 있어야 합니다.\n\n즉, 어떠한 구조체도 없이 객체 사이의 상태를 공유하거나, 무엇이든 쓸 수 있는 변경 가능한 데이터 유형을 사용하거나,\n같은 사이드 이펙트를 만들어내는 것을 여러개 만들거나하면 안됩니다. 여러분들이 이러한 것들을 지키며 코드를 작성한다면\n대부분의 다른 개발자들보다 행복할 수 있습니다.\n\n**안좋은 예:**\n```javascript\n// 아래 함수에 의해 참조되는 전역 변수입니다.\n// 이 전역 변수를 사용하는 또 하나의 함수가 있다고 생각해보세요. 이제 이 변수는 배열이 될 것이고, 프로그램을 망가뜨리겠죠.\nlet name = 'Ryan McDermott';\n\nfunction splitIntoFirstAndLastName() {\n  name = name.split(' ');\n}\n\nsplitIntoFirstAndLastName();\n\nconsole.log(name); // ['Ryan', 'McDermott'];\n```\n\n**좋은 예:**\n```javascript\nfunction splitIntoFirstAndLastName(name) {\n  return name.split(' ');\n}\n\nconst name = 'Ryan McDermott';\nconst newName = splitIntoFirstAndLastName(name);\n\nconsole.log(name); // 'Ryan McDermott';\nconsole.log(newName); // ['Ryan', 'McDermott'];\n```\n**[⬆ 상단으로](#목차)**\n\n### 사이드 이펙트를 피하세요 (part 2)\n자바스크립트에서는 기본타입 자료형은 값을 전달하고 객체와 배열은 참조를 전달합니다.\n객체와 배열인 경우를 한번 살펴봅시다. 우리가 만든 함수는 장바구니 배열에 변화를 주며\n이 변화는 구매목록에 어떤 상품을 추가하는 기능 같은 것을 말합니다.\n만약 `장바구니` 배열을 사용하는 어느 다른 함수가 있다면 이러한 추가에 영향을 받습니다.\n이것은 좋을 수도 있지만, 안좋을 수도 있습니다. 안좋은 예를 한번 상상해봅시다.\n\n유저가 구매하기 버튼을 눌러 `구매` 함수를 호출합니다. 이는 네트워크 요청을 생성하고 서버에 `장바구니` 배열을 보냅니다.\n하지만 네트워크 연결이 좋지않아서 `구매` 함수는 다시한번 네트워크 요청을 보내야 하는 상황이 생겼습니다.\n이때, 사용자가 네트워크 요청이 시작되기 전에 실수로 원하지 않는 상품의 \"장바구니에 추가\" 버튼을 실수로 클릭하면 어떻게될까요?\n실수가 있고난 뒤, 네트워크 요청이 시작되면 `장바구니에 추가` 함수 때문에 실수로 변경된 `장바구니` 배열을 서버에 보내게 됩니다.\n\n가장 좋은 방법은 `장바구니에 추가`는 항상 `장바구니` 배열을 복제하여 수정하고 복제본을 반환하는 것입니다.\n이렇게하면 장바구니 참조를 보유하고있는 다른 함수가 다른 변경 사항의 영향을 받지 않게됩니다.\n\n이 접근법에대해 말하고 싶은 것이 두가지 있습니다.\n\n1. 실제로 입력된 객체를 수정하고 싶은 경우가 있을 수 있지만 이러한 예제를 생각해보고 적용해보면 그런 경우는\n거의 없다는 것을 깨달을 수 있습니다. 그리고 대부분의 것들이 사이드 이펙트 없이 리팩토링 될 수 있습니다.\n2. 큰 객체를 복제하는 것은 성능 측면에서 값이 매우 비쌉니다. 운좋게도 이런게 큰 문제가 되지는 않습니다.\n왜냐하면 이러한 프로그래밍 접근법을 가능하게해줄 [좋은 라이브러리](https://facebook.github.io/immutable-js/)가 있기 때문입니다.\n이는 객체와 배열을 수동으로 복제하는 것처럼 메모리 집약적이지 않게 해주고 빠르게 복제해줍니다.\n\n**Bad:**\n```javascript\nconst addItemToCart = (cart, item) =\u003e {\n  cart.push({ item, date: Date.now() });\n};\n```\n\n**Good:**\n```javascript\nconst addItemToCart = (cart, item) =\u003e {\n  return [...cart, { item, date : Date.now() }];\n};\n```\n**[⬆ 상단으로](#목차)**\n\n### 전역 함수를 사용하지 마세요\n전역 환경을 사용하는 것은 JavaScript에서 나쁜 관행입니다. 왜냐하면 다른 라이브러리들과의 충돌이 일어날 수 있고,\n당신의 API를 쓰는 유저들은 운영환경에서 예외가 발생하기 전까지는 문제를 인지하지 못할 것이기 때문입니다. 예제를 하나 생각해봅시다.\nJavaScript의 네이티브 Array 메소드를 확장하여 두 배열 간의 차이를 보여줄 수있는 `diff` 메소드를 사용하려면 어떻게 해야할까요? \n새로운 함수를 `Array.prototype`에 쓸 수도 있지만, 똑같은 일을 시도한 다른 라이브러리와 충돌 할 수 있습니다.\n다른 라이브러리가 `diff` 메소드를 사용하여 첫번째 요소와 마지막 요소의 차이점을 찾으면 어떻게 될까요?\n이것이 그냥 ES2015/ES6의 classes를 사용해서 전역 `Array`를 상속해버리는 것이 훨씬 더 나은 이유입니다.\n\n**안좋은 예:**\n```javascript\nArray.prototype.diff = function diff(comparisonArray) {\n  const hash = new Set(comparisonArray);\n  return this.filter(elem =\u003e !hash.has(elem));\n};\n```\n\n**좋은 예:**\n```javascript\nclass SuperArray extends Array {\n  diff(comparisonArray) {\n    const hash = new Set(comparisonArray);\n    return this.filter(elem =\u003e !hash.has(elem));\n  }\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 명령형 프로그래밍보다 함수형 프로그래밍을 지향하세요\nJavaScript는 Haskell처럼 함수형 프로그래밍 언어는 아니지만 함수형 프로그래밍처럼 작성할 수 있습니다.\n함수형 언어는 더 깔끔하고 테스트하기 쉽습니다. 가능하면 이 방식을 사용하도록 해보세요.\n\n**안좋은 예:**\n```javascript\nconst programmerOutput = [\n  {\n    name: 'Uncle Bobby',\n    linesOfCode: 500\n  }, {\n    name: 'Suzie Q',\n    linesOfCode: 1500\n  }, {\n    name: 'Jimmy Gosling',\n    linesOfCode: 150\n  }, {\n    name: 'Gracie Hopper',\n    linesOfCode: 1000\n  }\n];\n\nlet totalOutput = 0;\n\nfor (let i = 0; i \u003c programmerOutput.length; i++) {\n  totalOutput += programmerOutput[i].linesOfCode;\n}\n```\n\n**좋은 예:**\n```javascript\nconst programmerOutput = [\n  {\n    name: 'Uncle Bobby',\n    linesOfCode: 500\n  }, {\n    name: 'Suzie Q',\n    linesOfCode: 1500\n  }, {\n    name: 'Jimmy Gosling',\n    linesOfCode: 150\n  }, {\n    name: 'Gracie Hopper',\n    linesOfCode: 1000\n  }\n];\n\nconst totalOutput = programmerOutput\n  .map(programmer =\u003e programmer.linesOfCode)\n  .reduce((acc, linesOfCode) =\u003e acc + linesOfCode, INITIAL_VALUE);\n```\n**[⬆ 상단으로](#목차)**\n\n### 조건문을 캡슐화 하세요\n\n**안좋은 예:**\n```javascript\nif (fsm.state === 'fetching' \u0026\u0026 isEmpty(listNode)) {\n  // ...\n}\n```\n\n**좋은 예:**\n```javascript\nfunction shouldShowSpinner(fsm, listNode) {\n  return fsm.state === 'fetching' \u0026\u0026 isEmpty(listNode);\n}\n\nif (shouldShowSpinner(fsmInstance, listNodeInstance)) {\n  // ...\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 부정조건문을 사용하지 마세요\n\n**안좋은 예:**\n```javascript\nfunction isDOMNodeNotPresent(node) {\n  // ...\n}\n\nif (!isDOMNodeNotPresent(node)) {\n  // ...\n}\n```\n\n**좋은 예:**\n```javascript\nfunction isDOMNodePresent(node) {\n  // ...\n}\n\nif (isDOMNodePresent(node)) {\n  // ...\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 조건문 작성을 피하세요\n조건문 작성을 피하라는 것은 매우 불가능한 일로 보입니다. 이 얘기를 처음 듣는 사람들은 대부분 \"`If`문 없이 어떻게 코드를 짜나요?\"라고 말합니다.\n하지만 다형성을 이용한다면 동일한 작업을 수행할 수 있습니다. 두번째 질문은 보통 \"네 좋네요 근데 내가 왜 그렇게 해야하나요?\"이죠.\n그에 대한 대답은, 앞서 우리가 공부했던 clean code 컨셉에 있습니다. 함수는 단 하나의 일만 수행하여야 합니다.\n당신이 함수나 클래스에 `if`문을 쓴다면 그것은 그 함수나 클래스가 한가지 이상의 일을 수행하고 있다고 말하는 것과 같습니다.\n기억하세요, 하나의 함수는 딱 하나의 일만 해야합니다.\n\n**안좋은 예:**\n```javascript\nclass Airplane {\n  // ...\n  getCruisingAltitude() {\n    switch (this.type) {\n      case '777':\n        return this.getMaxAltitude() - this.getPassengerCount();\n      case 'Air Force One':\n        return this.getMaxAltitude();\n      case 'Cessna':\n        return this.getMaxAltitude() - this.getFuelExpenditure();\n    }\n  }\n}\n```\n\n**좋은 예:**\n```javascript\nclass Airplane {\n  // ...\n}\n\nclass Boeing777 extends Airplane {\n  // ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude() - this.getPassengerCount();\n  }\n}\n\nclass AirForceOne extends Airplane {\n  // ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude();\n  }\n}\n\nclass Cessna extends Airplane {\n  // ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude() - this.getFuelExpenditure();\n  }\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 타입-체킹을 피하세요 (part 1)\nJavaScript는 타입이 정해져있지 않습니다. 이는 당신의 함수가 어떤 타입의 인자든 받을 수 있다는 것을 의미합니다.\n이런 JavaScript의 자유로움 때문에 여러 버그가 발생했었고 이 때문에 당신의 함수에 타입-체킹을 시도 할 수도 있습니다.\n하지만 타입-체킹 말고도 이러한 화를 피할 많은 방법들이 존재합니다. 첫번째 방법은 일관성 있는 API를 사용하는 것입니다.\n\n**안좋은 예:**\n```javascript\nfunction travelToTexas(vehicle) {\n  if (vehicle instanceof Bicycle) {\n    vehicle.pedal(this.currentLocation, new Location('texas'));\n  } else if (vehicle instanceof Car) {\n    vehicle.drive(this.currentLocation, new Location('texas'));\n  }\n}\n```\n\n**좋은 예:**\n```javascript\nfunction travelToTexas(vehicle) {\n  vehicle.move(this.currentLocation, new Location('texas'));\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 타입-체킹을 피하세요 (part 2)\n당신이 문자열, 정수, 배열등 기본 자료형을 사용하고 다형성을 사용할 수 없을 때 여전히 타입-체킹이 필요하다고 느껴진다면\nTypeScript를 도입하는 것을 고려해보는 것이 좋습니다. TypeScript는 표준 JavaScript 구문에 정적 타입을 제공하므로\n일반 JavaScript의 대안으로 사용하기에 좋습니다. JavaScript에서 타입-체킹을 할 때 문제점은 가짜 `type-safety`\n를 얻기위해 작성된 코드를 설명하기 위해서 많은 주석을 달아야한다는 점입니다. JavaScript로 코드를 작성할땐 깔끔하게 코드를 작성하고,\n좋은 테스트 코드를 짜야하며 좋은 코드 리뷰를 해야합니다. 그러기 싫다면 그냥 TypeScript(이건 제가 말했듯이, 좋은 대체재입니다!)를 쓰세요.\n\n**안좋은 예:**\n```javascript\nfunction combine(val1, val2) {\n  if (typeof val1 === 'number' \u0026\u0026 typeof val2 === 'number' ||\n      typeof val1 === 'string' \u0026\u0026 typeof val2 === 'string') {\n    return val1 + val2;\n  }\n  \n  throw new Error('Must be of type String or Number');\n}\n```\n\n**좋은 예:**\n```javascript\nfunction combine(val1, val2) {\n  return val1 + val2;\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 과도한 최적화를 지양하세요\n최신 브라우저들은 런타임에 많은 최적화 작업을 수행합니다. 대부분 당신이 코드를 최적화 하는 것은 시간낭비일 가능성이 많습니다.\n최적화가 부족한 곳이 어딘지를 알려주는 [좋은 자료](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers)가 여기 있습니다.\n이것을 참조하여 최신 브라우저들이 최적화 해주지 않는 부분만 최적화를 해주는 것이 좋습니다.\n\n**안좋은 예:**\n```javascript\n\n// 오래된 브라우저의 경우 캐시되지 않은 `list.length`를 통한 반복문은 높은 코스트를 가졌습니다.\n// 그 이유는 `list.length`를 매번 계산해야만 했기 때문인데, 최신 브라우저에서는 이것이 최적화 되었습니다.\nfor (let i = 0, len = list.length; i \u003c len; i++) {\n  // ...\n}\n```\n\n**좋은 예:**\n```javascript\nfor (let i = 0; i \u003c list.length; i++) {\n  // ...\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 죽은 코드를 지우세요\n\n죽은 코드는 중복된 코드 만큼이나 좋지 않습니다. 죽은 코드는 당신의 코드에 남아있을 어떠한 이유도 없습니다.\n호출되지 않는 코드가 있다면 그 코드는 지우세요! 그 코드가 여전히 필요해도 그 코드는 버전 히스토리에 안전하게\n남아있을 것입니다.\n\n**안좋은 예:**\n```javascript\nfunction oldRequestModule(url) {\n  // ...\n}\n\nfunction newRequestModule(url) {\n  // ...\n}\n\nconst req = newRequestModule;\ninventoryTracker('apples', req, 'www.inventory-awesome.io');\n\n```\n\n**좋은 예:**\n```javascript\nfunction newRequestModule(url) {\n  // ...\n}\n\nconst req = newRequestModule;\ninventoryTracker('apples', req, 'www.inventory-awesome.io');\n```\n**[⬆ 상단으로](#목차)**\n\n## **객체와 자료구조(Objects and Data Structures)**\n### getter와 setter를 사용하세요\nJavaScript는 인터페이스와 타입을 가지고있지 않고 이러한 패턴을 적용하기가 힘듭니다.\n왜냐하면 `public`이나 `private`같은 키워드가 없기 때문이죠.\n그렇기 때문에 getter 및 setter를 사용하여 객체의 데이터에 접근하는 것이 객체의 속성을 찾는 것보다 훨씬 낫습니다.\n\"왜요?\"라고 물으실 수도 있겠습니다. 왜 그런지에 대해서 몇 가지 이유를 두서없이 적어봤습니다.\n\n* 객체의 속성을 얻는 것 이상의 많은 것을 하고싶을 때, 코드에서 모든 접근자를 찾아 바꾸고 할 필요가 없습니다.\n* `set`할때 검증로직을 추가하는 것이 코드를 더 간단하게 만듭니다.\n* 내부용 API를 캡슐화 할 수 있습니다.\n* `getting`과 `setting`할 때 로그를 찾거나 에러처리를 하기 쉽습니다.\n* 클래스를 상속해서 디폴트 동작을 재정의할 수 있습니다.\n* 서버에서 객체 속성을 받아올 때 lazy load 할 수 있습니다.\n\n**안좋은 예:**\n```javascript\nclass BankAccount {\n  constructor() {\n    this.balance = 1000;\n  }\n}\n\nconst bankAccount = new BankAccount();\n\n// 신발을 구매할 때...\nbankAccount.balance -= 100;\n```\n\n**좋은 예:**\n```javascript\nclass BankAccount {\n  constructor(balance = 1000) {\n\t   this._balance = balance;\n  }\n\n  // getter/setter를 정의할 때 `get`, `set` 같은 접두사가 필요하지 않습니다.\n  set balance(amount) {\n      if (this.verifyIfAmountCanBeSetted(amount)) {\n        this._balance = amount;\n      }\n    }\n  \n  get balance() {\n    return this._balance;\n  }\n\n  verifyIfAmountCanBeSetted(val) {\n    // ...\n  }\n}\n\nconst bankAccount = new BankAccount();\n    \n// 신발을 구매할 때...\nbankAccount.balance -= shoesPrice;\n\n// balance 값을 얻을 때\nlet balance = bankAccount.balance;\n```\n**[⬆ 상단으로](#목차)**\n\n### 객체에 비공개 멤버를 만드세요\n클로져를 이용하면 가능합니다. (ES5 이하에서도)\n\n**안좋은 예:**\n```javascript\n\nconst Employee = function(name) {\n  this.name = name;\n};\n\nEmployee.prototype.getName = function getName() {\n  return this.name;\n};\n\nconst employee = new Employee('John Doe');\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe\ndelete employee.name;\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: undefined\n```\n\n**좋은 예:**\n```javascript\nfunction makeEmployee(name) {\n  return {\n    getName() {\n      return name;\n    },\n  };\n}\n\nconst employee = makeEmployee('John Doe');\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe\ndelete employee.name;\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe\n```\n**[⬆ 상단으로](#목차)**\n\n## **클래스(Classes)**\n### 단일 책임 원칙 (Single Responsibility Prinsiple, SRP)\nClean Code에서 말하길 \"클래스를 수정 할 때는 수정 해야하는 이유가 2개 이상 있으면 안됩니다\".\n이것은 하나의 클래스에 많은 기능을 쑤셔넣는 것이나 다름 없습니다. 마치 비행기를 탈때 가방을 1개만 가지고 탈 수\n있을 때 처럼 말이죠. 이 문제는 당신의 클래스가 개념적으로 응집되어 있지 않다는 것이고, 클래스를 바꿔야할 많은 이유가 됩니다.\n클래스를 수정하는데 들이는 시간을 줄이는 것은 중요합니다. 왜냐면 하나의 클래스에 너무 많은 기능들이 있고\n당신이 이 작은 기능들을 수정할 때 이 코드가 다른 모듈들에 어떠한 영향을 끼치는지 이해하기 어려울 수 있기 때문입니다.\n\n**안좋은 예:**\n```javascript\nclass UserSettings {\n  constructor(user) {\n    this.user = user;\n  }\n\n  changeSettings(settings) {\n    if (this.verifyCredentials()) {\n      // ...\n    }\n  }\n\n  verifyCredentials() {\n    // ...\n  }\n}\n```\n\n**좋은 예:**\n```javascript\nclass UserAuth {\n  constructor(user) {\n    this.user = user;\n  }\n\n  verifyCredentials() {\n    // ...\n  }\n}\n\n\nclass UserSettings {\n  constructor(user) {\n    this.user = user;\n    this.auth = new UserAuth(user);\n  }\n\n  changeSettings(settings) {\n    if (this.auth.verifyCredentials()) {\n      // ...\n    }\n  }\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 개방/폐쇄 원칙 (Open/Closed Principle, OCP)\nBertrand Meyer에 말에 의하면 \"소프트웨어 개체(클래스, 모듈, 함수 등)는 확장을 위해 개방적이어야 하며 수정시엔\n폐쇄적이어야 합니다.\" 이것에 의미는 무엇일까요? 이 원리는 기본적으로 사용자가 `.js` 소스 코드 파일을 열어 수동으로 조작하지 않고도\n모듈의 기능을 확장하도록 허용해야한다고 말합니다.\n\n**안좋은 예:**\n```javascript\nclass AjaxAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'ajaxAdapter';\n  }\n}\n\nclass NodeAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'nodeAdapter';\n  }\n}\n\nclass HttpRequester {\n  constructor(adapter) {\n    this.adapter = adapter;\n  }\n\n  fetch(url) {\n    if (this.adapter.name === 'ajaxAdapter') {\n      return makeAjaxCall(url).then((response) =\u003e {\n        // transform response and return\n      });\n    } else if (this.adapter.name === 'httpNodeAdapter') {\n      return makeHttpCall(url).then((response) =\u003e {\n        // transform response and return\n      });\n    }\n  }\n}\n\nfunction makeAjaxCall(url) {\n  // request and return promise\n}\n\nfunction makeHttpCall(url) {\n  // request and return promise\n}\n```\n\n**좋은 예:**\n```javascript\nclass AjaxAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'ajaxAdapter';\n  }\n\n  request(url) {\n    // request and return promise\n  }\n}\n\nclass NodeAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'nodeAdapter';\n  }\n\n  request(url) {\n    // request and return promise\n  }\n}\n\nclass HttpRequester {\n  constructor(adapter) {\n    this.adapter = adapter;\n  }\n\n  fetch(url) {\n    return this.adapter.request(url).then((response) =\u003e {\n      // transform response and return\n    });\n  }\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)\n이것은 매우 간단하지만 강력한 원칙입니다. 리스코프 원칙이란 자료형 S가 자료형 T의 하위형이라면,\n프로그램이 갖추어야 할 속성들(정확성, 수행되는 작업 등)의 변경사항 없이, 자료형 T의 객체를 자료형 S의 객체로\n교체(치환)할 수 있어야 한다는 원칙입니다.\n\n이 원칙을 예를 들어 설명하자면 당신이 부모 클래스와 자식 클래스를 가지고 있을 때 베이스 클래스와 하위 클래스를\n잘못된 결과 없이 서로 교환하여 사용할 수 있습니다. 여전히 이해가 안간다면 정사각형-직사각형 예제를 봅시다.\n수학적으로 정사각형은 직사각형이지만 상속을 통해 \"is-a\" 관계를 사용하여 모델링한다면 문제가 발생합니다.\n\n**안좋은 예:**\n```javascript\nclass Rectangle {\n  constructor() {\n    this.width = 0;\n    this.height = 0;\n  }\n\n  setColor(color) {\n    // ...\n  }\n\n  render(area) {\n    // ...\n  }\n\n  setWidth(width) {\n    this.width = width;\n  }\n\n  setHeight(height) {\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Rectangle {\n  setWidth(width) {\n    this.width = width;\n    this.height = width;\n  }\n\n  setHeight(height) {\n    this.width = height;\n    this.height = height;\n  }\n}\n\nfunction renderLargeRectangles(rectangles) {\n  rectangles.forEach((rectangle) =\u003e {\n    rectangle.setWidth(4);\n    rectangle.setHeight(5);\n    const area = rectangle.getArea(); // 정사각형일때 25를 리턴합니다. 하지만 20이어야 하는게 맞습니다.\n    rectangle.render(area);\n  });\n}\n\nconst rectangles = [new Rectangle(), new Rectangle(), new Square()];\nrenderLargeRectangles(rectangles);\n```\n\n**좋은 예:**\n```javascript\nclass Shape {\n  setColor(color) {\n    // ...\n  }\n\n  render(area) {\n    // ...\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(width, height) {\n    super();\n    this.width = width;\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Shape {\n  constructor(length) {\n    super();\n    this.length = length;\n  }\n\n  getArea() {\n    return this.length * this.length;\n  }\n}\n\nfunction renderLargeShapes(shapes) {\n  shapes.forEach((shape) =\u003e {\n      const area = shape.getArea();\n      shape.render(area);\n    });\n  }\n\nconst shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];\nrenderLargeShapes(shapes);\n```\n**[⬆ 상단으로](#목차)**\n\n### 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)\nJavaScript는 인터페이스가 없기 때문에 다른 원칙들처럼 딱 맞게 적용할 수는 없습니다.\n그러나, JavaScript에 타입 시스템이 없다 하더라도 중요하고 관계있는 원칙입니다.\n\nISP에 의하면 \"클라이언트는 사용하지 않는 인터페이스에 의존하도록 강요 받으면 안됩니다.\"\n덕 타이핑 때문에 인터페이스는 JavaScript에서는 암시적인 계약일 뿐입니다.\n\nJavaScript에서 이것을 보여주는 가장 좋은 예는 방대한 양의 설정 객체가 필요한 클래스입니다.\n클라이언트가 방대한 양의 옵션을 설정하지 않는 것이 좋습니다. 왜냐하면 대부분의 경우 설정들이 전부 다 필요한 건 아니기 때문입니다.\n설정을 선택적으로 할 수 있다면 \"무거운 인터페이스(fat interface)\"를 만드는 것을 방지할 수 있습니다.\n\n**안좋은 예:**\n```javascript\nclass DOMTraverser {\n  constructor(settings) {\n    this.settings = settings;\n    this.setup();\n  }\n\n  setup() {\n    this.rootNode = this.settings.rootNode;\n    this.animationModule.setup();\n  }\n\n  traverse() {\n    // ...\n  }\n}\n\nconst $ = new DOMTraverser({\n  rootNode: document.getElementsByTagName('body'),\n  animationModule() {} // 우리는 대부분의 경우 DOM을 탐색할 때 애니메이션이 필요하지 않습니다.\n  // ...\n});\n\n```\n\n**좋은 예:**\n```javascript\nclass DOMTraverser {\n  constructor(settings) {\n    this.settings = settings;\n    this.options = settings.options;\n    this.setup();\n  }\n\n  setup() {\n    this.rootNode = this.settings.rootNode;\n    this.setupOptions();\n  }\n\n  setupOptions() {\n    if (this.options.animationModule) {\n      // ...\n    }\n  }\n\n  traverse() {\n    // ...\n  }\n}\n\nconst $ = new DOMTraverser({\n  rootNode: document.getElementsByTagName('body'),\n  options: {\n    animationModule() {}\n  }\n});\n```\n**[⬆ 상단으로](#목차)**\n\n### 의존성 역전 원칙 (Dependency Inversion Principle, DIP)\n이 원칙은 두가지 중요한 요소를 가지고 있습니다.\n\n1. 상위 모듈은 하위 모듈에 종속되어서는 안됩니다. 둘 다 추상화에 의존해야 합니다.\n2. 추상화는 세부사항에 의존하지 않습니다. 세부사항은 추상화에 의해 달라져야 합니다.\n\n처음에는 이것을 이해하는데 어려울 수 있습니다. 하지만 만약 Angular.js로 작업해본적이 있다면\n의존성 주입(Dependency Injection) 형태로 이 원리를 구현한 것을 보았을 것입니다.\nDIP는 동일한 개념은 아니지만 상위 모듈이 하위 모듈의 세부사항을 알지 못하게 합니다.\n이는 의존성 주입을 통해 달성할 수 있습니다. DI의 장점은 모듈 간의 의존성을 감소시키는 데에 있습니다.\n모듈간의 의존성이 높을수록 코드를 리팩토링 하는데 어려워지고 이것은 매우 나쁜 개발 패턴들 중 하나입니다.\n\n앞에서 설명한 것처럼 JavaScript에는 인터페이스가 없으므로 추상화에 의존하는 것은 암시적인 약속입니다.\n이말인즉슨, 다른 객체나 클래스에 노출되는 메소드와 속성이 바로 암시적인 약속(추상화)가 된다는 것이죠.\n아래 예제에서 암시적인 약속은 `InventoryTracker`에대한 모든 요청 모듈이 `requestItems` 메소드를\n가질 것이라는 점입니다.\n\n**안좋은 예:**\n```javascript\nclass InventoryRequester {\n  constructor() {\n    this.REQ_METHODS = ['HTTP'];\n  }\n\n  requestItem(item) {\n    // ...\n  }\n}\n\nclass InventoryTracker {\n  constructor(items) {\n    this.items = items;\n\n    // 안좋은 이유: 특정 요청방법 구현에 대한 의존성을 만들었습니다.\n    // requestItems는 한가지 요청방법을 필요로 합니다.\n    this.requester = new InventoryRequester();\n  }\n\n  requestItems() {\n    this.items.forEach(item =\u003e {\n      this.requester.requestItem(item);\n    });\n  }\n}\n\nconst inventoryTracker = new InventoryTracker(['apples', 'bananas']);\ninventoryTracker.requestItems();\n```\n\n**좋은 예:**\n```javascript\nclass InventoryTracker {\n  constructor(items, requester) {\n    this.items = items;\n    this.requester = requester;\n  }\n\n  requestItems() {\n    this.items.forEach(item =\u003e {\n      this.requester.requestItem(item);\n    });\n  }\n}\n\nclass InventoryRequesterV1 {\n  constructor() {\n    this.REQ_METHODS = ['HTTP'];\n  }\n\n  requestItem(item) {\n    // ...\n  }\n}\n\nclass InventoryRequesterV2 {\n  constructor() {\n    this.REQ_METHODS = ['WS'];\n  }\n\n  requestItem(item) {\n    // ...\n  }\n}\n\n// 의존성을 외부에서 만들어 주입해줌으로써,\n// 요청 모듈을 새롭게 만든 웹소켓 사용 모듈로 쉽게 바꿔 끼울 수 있게 되었습니다.\nconst inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());\ninventoryTracker.requestItems();\n```\n**[⬆ 상단으로](#목차)**\n\n### ES5의 함수보다 ES2015/ES6의 클래스를 사용하세요\n기존 ES5의 클래스에서 이해하기 쉬운 상속, 구성 및 메소드 정의를 하는 건 매우 어렵습니다.\n매번 그런것은 아니지만 상속이 필요한 경우라면 클래스를 사용하는 것이 좋습니다.\n하지만 당신이 크고 더 복잡한 객체가 필요한 경우가 아니라면 클래스보다 작은 함수를 사용하세요.\n\n**안좋은 예:**\n```javascript\nconst Animal = function(age) {\n  if (!(this instanceof Animal)) {\n    throw new Error(\"Instantiate Animal with `new`\");\n  }\n    \n  this.age = age;\n};\n\nAnimal.prototype.move = function() {};\n\nconst Mammal = function(age, furColor) {\n  if (!(this instanceof Mammal)) {\n    throw new Error(\"Instantiate Mammal with `new`\");\n  }\n\n  Animal.call(this, age);\n  this.furColor = furColor;\n};\n\nMammal.prototype = Object.create(Animal.prototype);\nMammal.prototype.constructor = Mammal;\nMammal.prototype.liveBirth = function liveBirth() {};\n\nconst Human = function(age, furColor, languageSpoken) {\n  if (!(this instanceof Human)) {\n    throw new Error(\"Instantiate Human with `new`\");\n  }\n\n  Mammal.call(this, age, furColor);\n  this.languageSpoken = languageSpoken;\n};\n\nHuman.prototype = Object.create(Mammal.prototype);\nHuman.prototype.constructor = Human;\nHuman.prototype.speak = function speak() {};\n```\n\n**좋은 예:**\n```javascript\nclass Animal {\n  constructor(age) {\n    this.age = age;\n  }\n\n  move() { /* ... */ }\n}\n\nclass Mammal extends Animal {\n  constructor(age, furColor) {\n    super(age);\n    this.furColor = furColor;\n  }\n\n  liveBirth() { /* ... */ }\n}\n\nclass Human extends Mammal {\n  constructor(age, furColor, languageSpoken) {\n    super(age, furColor);\n    this.languageSpoken = languageSpoken;\n  }\n\n  speak() { /* ... */ }\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 메소드 체이닝을 사용하세요\nJavaScript에서 메소드 체이닝은 매우 유용한 패턴이며 jQuery나 Lodash같은 많은 라이브러리에서 이 패턴을 찾아볼 수 있습니다.\n이는 코드를 간결하고 이해하기 쉽게 만들어줍니다.\n이런 이유들로 메소드 체이닝을 쓰는 것을 권하고, 사용해본뒤 얼마나 코드가 깔끔해졌는지 꼭 확인 해보길 바랍니다.\n클래스 함수에서 단순히 모든 함수의 끝에 'this'를 리턴해주는 것으로 클래스 메소드를 추가로 연결할 수 있습니다.\n\n**안좋은 예:**\n```javascript\nclass Car {\n  constructor() {\n    this.make = 'Honda';\n    this.model = 'Accord';\n    this.color = 'white';\n  }\n\n  setMake(make) {\n    this.make = make;\n  }\n\n  setModel(model) {\n    this.model = model;\n  }\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  save() {\n    console.log(this.make, this.model, this.color);\n  }\n}\n\nconst car = new Car();\ncar.setColor('pink');\ncar.setMake('Ford');\ncar.setModel('F-150');\ncar.save();\n```\n\n**좋은 예:**\n```javascript\nclass Car {\n  constructor() {\n    this.make = 'Honda';\n    this.model = 'Accord';\n    this.color = 'white';\n  }\n\n  setMake(make) {\n    this.make = make;\n    // 메모: 체이닝을 위해 this를 리턴합니다.\n    return this;\n  }\n\n  setModel(model) {\n    this.model = model;\n    // 메모: 체이닝을 위해 this를 리턴합니다.\n    return this;\n  }\n\n  setColor(color) {\n    this.color = color;\n    // 메모: 체이닝을 위해 this를 리턴합니다.\n    return this;\n  }\n\n  save() {\n    console.log(this.make, this.model, this.color);\n    // 메모: 체이닝을 위해 this를 리턴합니다.\n    return this;\n  }\n}\n\nconst car = new Car()\n  .setColor('pink')\n  .setMake('Ford')\n  .setModel('F-150')\n  .save();\n```\n**[⬆ 상단으로](#목차)**\n\n### 상속보단 조합(composition)을 사용하세요\nGang of four의 [*Design Patterns*](https://en.wikipedia.org/wiki/Design_Patterns)에서 유명한\n전략으로 당신은 가능하다면 상속보다는 조합을 사용해야 합니다. 상속을 사용했을 때 얻을 수 있는 이득보다 조합을 사용했을 때 얻을 수\n있는 이득이 많기 때문입니다. 이 원칙의 요점은 당신이 계속 상속을 사용해서 코드를 작성하고자 할 때, 만약 조합을 이용하면\n더 코드를 잘 짤 수 있지 않을까 생각해보라는 것에 있습니다. 때때로는 이것이 맞는 전략이기 때문이죠.\n\n\"그럼 대체 상속을 언제 사용해야 되는 건가요?\"라고 물어 볼 수 있습니다. 이건 당신이 직면한 문제 상황에 달려있지만\n조합보다 상속을 쓰는게 더 좋을 만한 예시를 몇 개 들어 보겠습니다.\n\n1. 당신의 상속관계가 \"is-a\" 관계가 아니라 \"has-a\" 관계일 때 (사람-\u003e동물 vs. 유저-\u003e유저정보)\n2. 기반 클래스의 코드를 다시 사용할 수 있을 때 (인간은 모든 동물처럼 움직일 수 있습니다.)\n3. 기반 클래스를 수정하여 파생된 클래스 모두를 수정하고 싶을 때 (이동시 모든 동물이 소비하는 칼로리를 변경하고 싶을 때)\n\n**안좋은 예:**\n```javascript\nclass Employee {\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n\n  // ...\n}\n\n// 이 코드가 안좋은 이유는 Employees가 tax data를 \"가지고\" 있기 때문입니다.\n// EmployeeTaxData는 Employee 타입이 아닙니다.\nclass EmployeeTaxData extends Employee {\n  constructor(ssn, salary) {\n    super();\n    this.ssn = ssn;\n    this.salary = salary;\n  }\n\n  // ...\n}\n```\n\n**좋은 예:**\n```javascript\nclass EmployeeTaxData {\n  constructor(ssn, salary) {\n    this.ssn = ssn;\n    this.salary = salary;\n  }\n  \n  // ...\n}\n\nclass Employee {\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n\n  setTaxData(ssn, salary) {\n    this.taxData = new EmployeeTaxData(ssn, salary);\n  }\n  // ...\n}\n```\n**[⬆ 상단으로](#목차)**\n\n## **테스트(Testing)**\n테스트는 배포하는 것보다 중요합니다. 테스트 없이 배포한다는 것은 당신이 짜놓은 코드가 언제든 오작동해도 이상하지 않다는 얘기와 같습니다.\n테스트에 얼마나 시간을 투자할지는 당신이 함께 일하는 팀에 달려있지만 Coverage가 100%라는 것은 개발자들에게 높은 자신감과 안도감을 줍니다.\n이 말은 훌륭한 테스트 도구를 보유해야 하는 것 뿐만 아니라 [훌륭한 Coverage 도구](http://gotwarlost.github.io/istanbul/)를 사용해야한다는 것을 의미합니다.\n\n테스트 코드를 작성하지 않는다는 것은 그 무엇도 변명이 될 수 없습니다. 여기 [훌륭하고 많은 JavaScript 테스트 프레임워크들](http://jstherightway.org/#testing-tools)\n이 있습니다. 당신의 팀의 기호에 맞는 프레임워크를 고르기만 하면 됩니다. 테스트 프레임워크를 골랐다면 이제부터는 팀의 목표를\n모든 새로운 기능/모듈을 짤 때 테스트 코드를 작성하는 것으로 하세요. 만약 테스트 주도 개발 방법론(Test Driven Development, TDD)이 당신에게 맞는 방법이라면\n그건 훌륭한 개발 방법이 될 수 있습니다. 그러나 중요한 것은 당신이 어떠한 기능을 개발하거나 코드를 리팩토링 할 때\n당신이 정한 Coverage 목표를 달성하는 것에 있습니다.\n\n### 테스트 컵셉\n\n**안좋은 예:**\n```javascript\nconst assert = require('assert');\n\ndescribe('MakeMomentJSGreatAgain', () =\u003e {\n  it('handles date boundaries', () =\u003e {\n    let date;\n\n    date = new MakeMomentJSGreatAgain('1/1/2015');\n    date.addDays(30);\n    assert.equal('1/31/2015', date);\n\n    date = new MakeMomentJSGreatAgain('2/1/2016');\n    date.addDays(28);\n    assert.equal('02/29/2016', date);\n\n    date = new MakeMomentJSGreatAgain('2/1/2015');\n    date.addDays(28);\n    assert.equal('03/01/2015', date);\n  });\n});\n```\n\n**좋은 예:**\n```javascript\nconst assert = require('assert');\n\ndescribe('MakeMomentJSGreatAgain', () =\u003e {\n  it('handles 30-day months', () =\u003e {\n    const date = new MakeMomentJSGreatAgain('1/1/2015');\n    date.addDays(30);\n    assert.equal('1/31/2015', date);\n  });\n\n  it('handles leap year', () =\u003e {\n    const date = new MakeMomentJSGreatAgain('2/1/2016');\n    date.addDays(28);\n    assert.equal('02/29/2016', date);\n  });\n\n  it('handles non-leap year', () =\u003e {\n    const date = new MakeMomentJSGreatAgain('2/1/2015');\n    date.addDays(28);\n    assert.equal('03/01/2015', date);\n  });\n});\n```\n**[⬆ 상단으로](#목차)**\n\n## **동시성(Concurrency)**\n### Callback 대신 Promise를 사용하세요\nCallback은 깔끔하지 않습니다. 그리고 엄청나게 많은 중괄호 중첩을 만들어 냅니다.\nES2015/ES6에선 Promise가 내장되어 있습니다. 이걸 쓰세요!\n\n**안좋은 예:**\n```javascript\nrequire('request').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin', (requestErr, response) =\u003e {\n  if (requestErr) {\n    console.error(requestErr);\n  } else {\n    require('fs').writeFile('article.html', response.body, (writeErr) =\u003e {\n      if (writeErr) {\n        console.error(writeErr);\n      } else {\n        console.log('File written');\n      }\n    });\n  }\n});\n\n```\n\n**좋은 예:**\n```javascript\nrequire('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin')\n  .then((response) =\u003e {\n    return require('fs-promise').writeFile('article.html', response);\n  })\n  .then(() =\u003e {\n    console.log('File written');\n  })\n  .catch((err) =\u003e {\n    console.error(err);\n  });\n\n```\n**[⬆ 상단으로](#목차)**\n\n### Async/Await은 Promise보다 더욱 깔끔합니다\nPromise도 Callback에 비해 정말 깔끔하지만 ES2017/ES8에선 async와 await이 있습니다.\n이들은 Callback에대한 더욱 깔끔한 해결책을 줍니다. 오직 필요한 것은 함수앞에 `async`를 붙이는 것 뿐입니다.\n그러면 함수를 논리적으로 연결하기위해 더이상 `then`을 쓰지 않아도 됩니다. \n만약 당신이 ES2017/ES8 사용할 수 있다면 이것을 사용하세요!\n\n**안좋은 예:**\n```javascript\nrequire('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin')\n  .then(response =\u003e {\n    return require('fs-promise').writeFile('article.html', response);\n  })\n  .then(() =\u003e {\n    console.log('File written');\n  })\n  .catch(err =\u003e {\n    console.error(err);\n  })\n\n```\n\n**좋은 예:**\n```javascript\nasync function getCleanCodeArticle() {\n  try {\n    const response = await require('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin');\n    await require('fs-promise').writeFile('article.html', response);\n    console.log('File written');\n  } catch(err) {\n    console.error(err);\n  }\n}\n```\n**[⬆ 상단으로](#목차)**\n\n## **에러 처리(Error Handling)**\n에러를 뱉는다는 것은 좋은 것입니다! 즉, 프로그램에서 무언가가 잘못되었을 때 런타임에서 성공적으로 확인되면 \n현재 스택에서 함수 실행을 중단하고 (노드에서) 프로세스를 종료하고 스택 추적으로 콘솔에서 사용자에게 \n그 이유를 알려줍니다.\n \n### 단순히 에러를 확인만 하지마세요\n단순히 에러를 확인하는 것만으로 그 에러가 해결되거나 대응 할 수 있게 되는 것은 아닙니다.\n`console.log`를 통해 콘솔에 로그를 기록하는 것은 에러 로그를 잃어버리기 쉽기 때문에 좋은 방법이 아닙니다.\n만약에 `try/catch`로 어떤 코드를 감쌌다면 그건 당신이 그 코드에 어떤 에러가 날지도 모르기 때문에 감싼 것이므로\n그에대한 계획이 있거나 어떠한 장치를 해야합니다.\n\n**안좋은 예:**\n```javascript\ntry {\n  functionThatMightThrow();\n} catch (error) {\n  console.log(error);\n}\n```\n\n**좋은 예:**\n```javascript\ntry {\n  functionThatMightThrow();\n} catch (error) {\n  // 첫번째 방법은 console.error를 이용하는 것입니다. 이건 console.log보다 조금 더 알아채기 쉽습니다.\n  console.error(error);\n  // 다른 방법은 유저에게 알리는 방법입니다.\n  notifyUserOfError(error);\n  // 또 다른 방법은 서비스 자체에 에러를 기록하는 방법입니다.\n  reportErrorToService(error);\n  // 혹은 그 어떤 방법이 될 수 있습니다.\n}\n```\n**[⬆ 상단으로](#목차)**\n\n\n### Promise가 실패된 것을 무시하지 마세요\n위의 원칙과 같은 이유입니다.\n\n**안좋은 예:**\n```javascript\ngetdata()\n.then(data =\u003e {\n  functionThatMightThrow(data);\n})\n.catch(error =\u003e {\n  console.log(error);\n});\n```\n\n**좋은 예:**\n```javascript\ngetdata()\n.then(data =\u003e {\n  functionThatMightThrow(data);\n})\n.catch(error =\u003e {\n  // 첫번째 방법은 console.error를 이용하는 것입니다. 이건 console.log보다 조금 더 알아채기 쉽습니다.\n  console.error(error);\n  // 다른 방법은 유저에게 알리는 방법입니다.\n  notifyUserOfError(error);\n  // 또 다른 방법은 서비스 자체에 에러를 기록하는 방법입니다.\n  reportErrorToService(error);\n  // 혹은 그 어떤 방법이 될 수 있습니다.\n});\n```\n\n**[⬆ 상단으로](#목차)**\n\n## **포맷팅(Formatting)**\n포맷팅은 주관적입니다. 여기에 있는 많은 규칙과 마찬가지로 따르기 쉬운 규칙들이 있습니다.\n여기서 알아야 할 것은 포맷팅에 대해 과도하게 신경쓰는 것은 의미없다는 것입니다.\n포맷팅 체크를 자동으로 해주는 [많은 도구들](http://standardjs.com/rules.html)이 있기 때문입니다.\n이중 하나를 골라 사용하세요. 개발자들끼리 포맷팅에대해 논쟁하는 것만큼 시간과 돈을 낭비하는 것이 없습니다.\n\n자동으로 서식을 교정해주는 것(들여쓰기, 탭이냐 스페이스냐, 작은 따옴표냐 큰따옴표냐)에 해당하지 않는 사항에\n대해서는 몇가지 지침을 따르는 것이 좋습니다.\n\n### 일관된 대소문자를 사용하세요\nJavaScript에는 정해진 타입이 없기 때문에 대소문자를 구분하는 것으로 당신의 변수나 함수명 등에서 많은 것을 알 수 있습니다.\n이 규칙 또한 주관적이기 때문에 당신이 팀이 선택한 규칙들을 따르세요 중요한건 항상 일관성 있게 사용해야 한다는 것입니다.\n\n**안좋은 예:**\n```javascript\nconst DAYS_IN_WEEK = 7;\nconst daysInMonth = 30;\n\nconst songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];\nconst Artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];\n\nfunction eraseDatabase() {}\nfunction restore_database() {}\n\nclass animal {}\nclass Alpaca {}\n```\n\n**좋은 예:**\n```javascript\nconst DAYS_IN_WEEK = 7;\nconst DAYS_IN_MONTH = 30;\n\nconst songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];\nconst artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];\n\nfunction eraseDatabase() {}\nfunction restoreDatabase() {}\n\nclass Animal {}\nclass Alpaca {}\n```\n**[⬆ 상단으로](#목차)**\n\n### 함수 호출자와 함수 피호출자는 가깝게 위치시키세요\n어떤 함수가 다른 함수를 호출하면 그 함수들은 소스 파일 안에서 서로 수직으로 근접해 있어야 합니다.\n이상적으로는 함수 호출자를 함수 피호출자 바로 위에 위치시켜야 합니다. 우리는 코드를 읽을때 신문을 읽듯\n위에서 아래로 읽기 때문에 코드를 작성 할 때도 읽을 때를 고려하여 작성 해야합니다.\n\n**안좋은 예:**\n```javascript\nclass PerformanceReview {\n  constructor(employee) {\n    this.employee = employee;\n  }\n\n  lookupPeers() {\n    return db.lookup(this.employee, 'peers');\n  }\n\n  lookupManager() {\n    return db.lookup(this.employee, 'manager');\n  }\n\n  getPeerReviews() {\n    const peers = this.lookupPeers();\n    // ...\n  }\n\n  perfReview() {\n    this.getPeerReviews();\n    this.getManagerReview();\n    this.getSelfReview();\n  }\n\n  getManagerReview() {\n    const manager = this.lookupManager();\n  }\n\n  getSelfReview() {\n    // ...\n  }\n}\n\nconst review = new PerformanceReview(user);\nreview.perfReview();\n```\n\n**좋은 예:**\n```javascript\nclass PerformanceReview {\n  constructor(employee) {\n    this.employee = employee;\n  }\n\n  perfReview() {\n    this.getPeerReviews();\n    this.getManagerReview();\n    this.getSelfReview();\n  }\n\n  getPeerReviews() {\n    const peers = this.lookupPeers();\n    // ...\n  }\n\n  lookupPeers() {\n    return db.lookup(this.employee, 'peers');\n  }\n\n  getManagerReview() {\n    const manager = this.lookupManager();\n  }\n\n  lookupManager() {\n    return db.lookup(this.employee, 'manager');\n  }\n\n  getSelfReview() {\n    // ...\n  }\n}\n\nconst review = new PerformanceReview(employee);\nreview.perfReview();\n```\n\n**[⬆ 상단으로](#목차)**\n\n## **주석(Comments)**\n### 주석은 단지 그 로직이 복잡하다는 것을 말 할 뿐입니다\n주석을 다는것은 사과해야할 일이며 필수적인 것이 아닙니다. 좋은 코드는 *코드 자체*로 말합니다.\n\n**안좋은 예:**\n```javascript\nfunction hashIt(data) {\n  // 이건 해쉬입니다.\n  let hash = 0;\n\n  // lengh는 data의 길이입니다.\n  const length = data.length;\n\n  // 데이터의 문자열 개수만큼 반복문을 실행합니다.\n  for (let i = 0; i \u003c length; i++) {\n    // 문자열 코드를 얻습니다.\n    const char = data.charCodeAt(i);\n    // 해쉬를 만듭니다.\n    hash = ((hash \u003c\u003c 5) - hash) + char;\n    // 32-bit 정수로 바꿉니다.\n    hash \u0026= hash;\n  }\n}\n```\n\n**좋은 예:**\n```javascript\n\nfunction hashIt(data) {\n  let hash = 0;\n  const length = data.length;\n\n  for (let i = 0; i \u003c length; i++) {\n    const char = data.charCodeAt(i);\n    hash = ((hash \u003c\u003c 5) - hash) + char;\n\n    // 32-bit 정수로 바꿉니다.\n    hash \u0026= hash;\n  }\n}\n\n```\n**[⬆ 상단으로](#목차)**\n\n### 주석으로 된 코드를 남기지 마세요\n버전 관리 도구가 존재하기 때문에 코드를 주석으로 남길 이유가 없습니다.\n \n**안좋은 예:**\n```javascript\ndoStuff();\n// doOtherStuff();\n// doSomeMoreStuff();\n// doSoMuchStuff();\n```\n\n**좋은 예:**\n```javascript\ndoStuff();\n```\n**[⬆ 상단으로](#목차)**\n\n### 코드 기록을 주석으로 남기지 마세요\n버전 관리 도구를 이용해야하는 것을 꼭 기억하세요. 죽은 코드도 불필요한 설명도 특히 코드의 기록에 대한 주석도\n필요하지 않습니다. 코드의 기록에 대해 보고 싶다면 `git log`를 사용하세요!\n\n**안좋은 예:**\n```javascript\n/**\n * 2016-12-20: 모나드 제거했음, 이해는 되지 않음 (RM)\n * 2016-10-01: 모나드 쓰는 로직 개선 (JP)\n * 2016-02-03: 타입체킹 하는부분 제거 (LI)\n * 2015-03-14: 버그 수정 (JR)\n */\nfunction combine(a, b) {\n  return a + b;\n}\n```\n\n**좋은 예:**\n```javascript\nfunction combine(a, b) {\n  return a + b;\n}\n```\n**[⬆ 상단으로](#목차)**\n\n### 코드의 위치를 설명하지 마세요\n이건 정말 쓸데 없습니다. 적절한 들여쓰기와 포맷팅을 하고 함수와 변수의 이름에 의미를 부여하세요.\n\n**안좋은 예:**\n```javascript\n////////////////////////////////////////////////////////////////////////////////\n// 스코프 모델 정의\n////////////////////////////////////////////////////////////////////////////////\n$scope.model = {\n  menu: 'foo',\n  nav: 'bar'\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// actions 설정\n////////////////////////////////////////////////////////////////////////////////\nconst actions = function() {\n  // ...\n};\n```\n\n**좋은 예:**\n```javascript\n$scope.model = {\n  menu: 'foo',\n  nav: 'bar'\n};\n\nconst actions = function() {\n  // ...\n};\n```\n**[⬆ 상단으로](#목차)**\n\n## 번역(Translation)\n\n다른 언어로도 읽을 수 있습니다:\n\n  - ![br](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Brazil.png) **Brazilian Portuguese**: [fesnt/clean-code-javascript](https://github.com/fesnt/clean-code-javascript)\n  - ![cn](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/China.png) **Chinese**: [alivebao/clean-code-js](https://github.com/alivebao/clean-code-js)\n  - ![de](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Germany.png) **German**: [marcbruederlin/clean-code-javascript](https://github.com/marcbruederlin/clean-code-javascript)\n  - ![kr](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/South-Korea.png) **Korean**: [qkraudghgh/clean-code-javascript-ko](https://github.com/qkraudghgh/clean-code-javascript-ko)\n  - ![ru](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Russia.png) **Russian**: [BoryaMogila/clean-code-javascript-ru/](https://github.com/BoryaMogila/clean-code-javascript-ru/)\n\n**[⬆ 상단으로](#목차)**\n\n","disqusShortname":"gmground","disqusConfig":{"url":"https://gyumindev.github.io/post/clean-code-javascript-ko","identifier":"clean-code-javascript-ko","title":"clean-code-javascript-ko"}}},"page":"/post","pathname":"/post","query":{"name":"clean-code-javascript-ko"},"buildId":"7cf28e76-71b0-4e5a-892a-1c761e451d8a","assetPrefix":"","nextExport":true,"err":null,"chunks":[]}
          module={}
          __NEXT_LOADED_PAGES__ = []
          __NEXT_LOADED_CHUNKS__ = []

          __NEXT_REGISTER_PAGE = function (route, fn) {
            __NEXT_LOADED_PAGES__.push({ route: route, fn: fn })
          }

          __NEXT_REGISTER_CHUNK = function (chunkName, fn) {
            __NEXT_LOADED_CHUNKS__.push({ chunkName: chunkName, fn: fn })
          }

          false
        </script><script async="" id="__NEXT_PAGE__/post" src="/_next/7cf28e76-71b0-4e5a-892a-1c761e451d8a/page/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/7cf28e76-71b0-4e5a-892a-1c761e451d8a/page/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/_next/7cf28e76-71b0-4e5a-892a-1c761e451d8a/page/_error.js"></script><script src="/_next/static/commons/main-b281c6af7916d7257e47.js" async=""></script></body></html>